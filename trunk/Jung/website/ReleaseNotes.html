<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>JUNG Release Notes</title>
</head>
<body>
These release notes may be found at <a
 href="http://jung.sourceforge.net/ReleaseNotes.html">http://jung.sourceforge.net/ReleaseNotes.html</a>
<br>
<br>
Each release consists of several files. Since version 1.4, these have
included:
<dl>
  <dt>jung-#.#.#.jar</dt>
  <dd>The core and sample libraries; without source or tests.</dd>
  <dt>jung-#.#.#-src.jar</dt>
  <dd>The core and sample libraries with source</dd>
  <dt>jung-#.#.#.zip</dt>
  <dd>The full source distribution, with samples, source, Ant build
file, and JUnit tests. Contains jung-#.#.#.jar within it.</dd>
  <dt>jung-#.#.#-doc.zip</dt>
  <dd>The zipped Javadoc documentation.</dd>
</dl>

<h2>Release Notes</h2>

<h3>1.7.6 (Martin Luther King/Groundhog Day 2007)</h3>

<p><b>Bug Fixes</b>
<ul>
<li/>Fixed typecasting error in <code>SubsetManager</code>.
<li/>Fixed problem leading to <code>NullPointerException</code> in <code>PluggableRenderer.paintIconForVertex()</code>.
<li/><code>GraphZoomScrollPane</code> was fixed to properly handle view
scaling. ScrollBar range was restored to the min max of the actual
layout area, instead of a larger area.
<li/>Several fixes were made for Java6 to prevent class cast exceptions
when a transformed Shape was cast to a GeneralPath.
<li/><code>VisualizationViewer</code>'s <code>paintComponent</code> is no
longer synchronized.
<li/><code>VertexShapeFactory</code>'s polygons were fixed for more precise
centering over the vertex location point.
<li/>When vertex shapes were used as a fallback for a vertex icon, the vertex
shapes were not positioned properly.
<li/>Gradient painted edges were invisible for loop edges. Added a hack to 
fix it.
<li/>Added logic to not show tooltips on hidden vertices and edges.
<li/><code>SpringLayout</code> modified to address <code>NullPointerException</code> problem for 
graphs which are modified after the Layout is created.  (<b>Note</b>: this was
actually fixed in 1.7.5, but not documented until now.)
<li/>Fixed <code>FRLayout</code> bug relating to calculation of vertex positions in
the presence of locked vertices.
</ul>
</p>

<hr>

<h3>1.7.5 (Birth of the Bab 2006) </h3>

<p><b>New Features</b>
<ul>
<li/><code>Layout.isLocked(Vertex)</code> is required to report the locked state of
the specified vertex (that is, whether the position of the vertex can be updated 
by the layout algorithm), as determined by calls to <code>lockVertex</code> and 
<code>unlockVertex</code>.  This supersedes and replaces the now-deprecated 
<code>AbstractLayout.dontMove(Vertex)</code>, which now calls <code>isLocked</code> 
internally.  
<li/><code>AbsoluteCrossoverScalingControl</code> is a new class that allows
the user to set an absolute scale instead of a scale relative to a previous value.
At this time, there are no demos using this class.
</ul>

<p><b>Changes</b>
<ul>
<li/><code>PluggableRenderer</code> now uses the following logic to render an individual
vertex (changed portion italicized):
	<ol>
	<li/>If there is a non-null <code>VertexIconFunction</code>
		<ul>
		<li/>if there is a non-null <code>Icon</code> for this vertex, that icon is painted
		<li/>otherwise, <i>the <code>Shape</code> for this vertex is painted</i>
			<br>previously, a "broken image" icon was painted if the icon was null
		</ul>
	<li/>otherwise, the <code>Shape</code> for this vertex is painted. 
	</ol>
	If the user wants a broken image to be displayed if the <code>VertexIconFunction</code>
	cannot load an icon for the vertex, it is now the user's responsibility to provide
	a <code>VertexIconFunction</code> that checks the result of the load for "null" and 
	returns a "broken image" icon.
	<br>This change allows users to render some vertices as icons and others as shapes,
	at their option, simply by specifying which vertices have a non-null icon; this can
	be used, for example, to render the selected vertex as an icon.  (Of course, in this case
	the <code>VertexIconFunction</code> would need to have access to the <code>PickedInfo</code>
	instance.)
<li/><code>GraphZoomScrollPane</code> has been modified so that the scroll bars move a
rotated graph display in the expected direction. This was done by calculating the current
rotation, removing it, translating the graph, and then restoring the rotation. Additionally,
the GraphZoomScrollPane now calculates its range based on the actual size of the layout
and the size of the viewer. Changes to the layout size will automatically be adjusted for
by the scroll-bars.
<li/><code>MapBinaryHeap</code> now implements the <code>Collection</code> interface.
In particular, it now includes a <code>contains(Object)</code> method, an <code>iterator()</code>
method, and the <code>insert</code> method has been renamed to <code>add</code> for 
compatibility.  Note: the <code>Iterator</code> supplied does not support removal, 
and the methods which remove arbitrary elements (<code>remove, removeAll, retainAll</code>)
are not supported.
<li/>Seed <code>EdgeShape</code> instances must now be defined as spanning from coordinates
(0,0) to (1,0). These shapes are rotated, scaled, and translated into position for each
edge displayed in the graph. Previously, the 'seed' edge shape was first scaled by its
bounds, but that technique led to incorrect edge drawing when an edge shape's bounds
exceeded its endpoints. As an example, consider an edge shape that passes and returns
to its endpoint. Users who wish to use a seed edge shape that is not defined from 
coordinates (0,0) to (1,0) should first transform their seed edge shape to conform
to this size.
<li/><code>EdgeWeightLabeller</code> now includes a <code>removeWeight</code> method to allow
the user to clear obsolete weights from this decorator, and a <code>clear</code>
method that clears all weights from this decorator.
<li/><code>UserDatumNumber{Vertex,Edge}Value</code> now each contain a constructor that allow
the user to specify the <code>CopyAction</code> for the datum to be added.  (The default
remains <code>REMOVE</code>.)
<li/><code>BernoulliEdgePermuter</code> now accepts mixed-mode graphs (graphs which permit
directed and undirected edges); if the graph only permits undirected edges, only undirected
edges are created; otherwise directed edges are created.
<li/><code>GraphMLFileHandler</code> now creates <code>SparseGraph</code> instances; this 
reflects the fact that GraphML files can contain both directed and undirected edges 
(the edge default directionality is only a default, not a constraint) and can contain
parallel edges.  
<br><b>NOTE</b>: this means that graphs read in from GraphML files will, from now on, 
never be of type <code>DirectedGraph</code> or <code>UndirectedGraph</code> or enforce the 
corresponding constraints; code which assumes these types or constraints will fail.
<li/><code>CrossoverScalingControl</code>: Added documentation and clarified variable
names. Removed improper extends class.
<li/><code>AbstractLensSupport</code>: The visible controls were simplified.
<li/><code>GraphMouse</code> classes: Changed in/out scale values to 1.1f and 1/1.1f to
improve accuracy. Previous values of 1.1f and 0.9f caused a 'creep' in scale values
when applied repeatedly.
</ul>

<p><b>Bug Fixes</b>
<ul>
<li/><code>DijkstraShortestPath.getPath</code> now properly checks to make sure that its 
inputs are elements of the constructor-specified graph; if they are not, an 
<code>IllegalArgumentException</code> is thrown.
<li/><code>AbstractRanker</code> and <code>PageRank</code> now no longer assume that
input edge weights are represented as <code>MutableDouble</code> values; instead 
they are assumed to be of the (more general) type <code>Number</code>.
<li/>Javadoc corrections: <code>BetweennessCentrality</code> and <code>PajekNetReader</code>.
<li/><code>PajekNetReader</code>: now correctly handles different combinations of vertex
labels and coordinates, and permits unquoted labels. 
<li/><code>VertexIconAndShapeFunction</code> and <code>VertexImageShaperDemo</code> now each
check to make sure that the fetched <code>Icon</code> has > 0 width and height before 
attempting to cache the image.  (This handles the case where the icon is not successfully
loaded prior to its attempted first use.)
<li/><code>MouseListenerTranslator.getVertex()</code> now correctly calls 
<code>vv.inverseViewTransform()</code> to get the vertex coordinates (rather than 
<code>vv.inverseTransform()</code>).
<li/><code>GraphMLFile.saveUserData</code>: now includes the following checks (if either
is true, nothing is written for the corresponding key):
	<ul>
	<li/>if the <code>CopyAction</code> for a user datum is <code>UserData.REMOVE</code>
	<li/>if the user datum is null
	</ul>
<li/><code>GraphMLFile.saveEdgesSection()</code> now properly puts a space after the edge
directedness tag.
<li/><code>PluggableRenderer</code>:
	<ul>
	<li/>Fixed occasional arrow orientation problem by setting a maximum number of iterations
	inside <code>getLastOutsideSegment</code>.
	<li/>Fixed <code>GeneralPath</code> typecasting problem that can occur with Java6.
	</ul>
<li/><code>GradientEdgePaintFunction</code> fixed so that loop edges no longer vanish.
</ul>

<hr/>

<h3>1.7.4 (Ghana Independence Day 2006)</h3>

<p><b>New Features</b>
<ul>
<li/><code>Pair</code> now defines a more user-friendly <code>toString</code> method. 
<li/><code>TestGraphs.generateMixedRandomGraph</code> now has an optional 
argument specifying whether parallel edges are allowed in the generated graph.
</ul>

<p><b>Bug Fixes</b>
<ul>
<li/><code>BarabasiAlbertGenerator</code>: fixed a bug in the handling of parallel edges
(introduced in 1.7.3; this caused <code>PluggableRendererDemo</code>, and anything
else using <code>TestGraphs.generateMixedRandomGraph</code>, to fail in version 1.7.3).
<li/><code>SpringLayout</code>: removed confusing console output.
<li/><code>DefaultGraphLabelRenderer</code> now correctly uses the <code>Font</code>
(if non-<code>null</code>) argument given to <code>getGraphLabelRendererComponent</code>.
(Previously it had been using the <code>VisualizationViewer</code> default font,
regardless of the argument's value.)
</ul>

<hr/>

<h3>1.7.3 (Dr. Seuss' Birthday 2006)</h3>

<p><b>New Features</b>
<ul>
<li/><code>MagnifyTransformer</code> and <code>MagnifyShapeTransformer</code> were added
to supply a magnifying glass like examiner lens feature. They are similar to the
hyperbolic projection classes, but they do not distort the graph layout or shapes.
<code>LensDemo</code> (formerly <code>HyperbolicLensDemo</code>) has added these classes so that they can be
easily compared with the hyperbolic transform classes.
</ul>
<p><b>Changes</b>
<ul>
<li/>Constructor added to <code>DefaultSettableVertexLocationFunction</code> that takes
a <code>VertexLocationFunction</code> and initializes the locations in the map.
This will make it easier to load pre-existing vertices when changing layouts.
<li/>Changed the lens controls for the <code>HyperbolicLensSupport</code> so that
they are drawn in the foreground <code>PostRenderPaintable</code>.
<li/>A grid-like graph option was added to <code>LensDemo</code> to
show the lens effects more clearly.
<li/>The Hyperbolic projection support classes have been refactored to better represent
their role as support classes for a special transform that is applied within an elliptical
shaped Lens area of the visualization. <code>HyperbolicTransformer</code> and <code>HyperbolicShapeTransformer</code>
now extend a generalized <code>LensTransformer</code> class that applies the transform
within the lens. In addition to the hyperbolic transform classes, there are two more
extensions to <code>LensTransformer</code>. They are <code>MagnifyTransformer</code> and
<code>MagnifyShapeTransformer</code>, which only zoom the area within the elliptical
lens. See the new version of <code>LensDemo</code> as an example.
<li/><code>PluggableRenderer</code> has been changed internally so that it sets the font
for graph labels before it sets the text.
<li/><code>DegreeDistributions</code> now has a <code>getDegreeValues</code> method
(analogous with <code>getIndegreeValues</code>, etc.).
<li/><code>GraphZoomScrollPane</code> now saves the scale value that is computed the first
time the visual components are realized. This value is used to normalize the scale value
that subsequently determines the size of the scrollbar thumb adjusters. In most cases, the
initial scale will be 1.0, but in cases where the user has initialized the graph layout
to be a different size than the <code>VisualizationViewer</code>, this change will keep
the scrollbar sizes consistent with the initial view that the user has established.
<li/><code>BarabasiAlbertGenerator</code> now lets the user specify whether it is
permissible to create parallel edges; the default is "no parallel edges", which differs
from the previous default of "allow parallel edges".
<li/><code>StructuralHoles</code>: changed visibility of <code>localConstraint</code>
and <code>aggregateConstraint</code> to <code>public</code>.
</ul>
<p>
<p><b>Bug Fixes</b>
<ul>
<li/><code>LensDemo</code> changed to use a <code>LayoutScalingControl</code>
for the zoom buttons when in the hyperbolic projection mode. This mirrors the
behavior of the <code>GraphMouse</code> in that mode.
<li/>Changed the <code>EditingPopupGraphMousePlugin</code> so that after you add a new
Vertex, it locks all existing
Vertices prior to calling restart. This makes the behavior consistent with the
<code>EditingGraphMousePlugin</code>.
<li/>Fixed level of second arrowHit test in <code>PluggableRenderer</code> so that hits are 
computed properly.
<li/><code>GraphLabelRenderer</code> and <code>DefaultGraphLabelRenderer</code> changed to
pass <code>Font</code> parameter in <code>getGraphLabelRenderer</code> method. This should
help the label to correctly set its size.
<li/><code>EdmondsKarpMaxFlow</code>: internal method <code>finalizeIterations</code> now 
correctly casts the capacities to <code>Number</code> (rather than <code>MutableInteger</code>); 
also fixed typos in Javadoc.
<li/><code>BarabasiAlbertGenerator</code>: now creates vertices appropriate to the 
specified directionality of the graph.  (Previously the vertices created could only attach
to undirected edges.)
<li/><code>StructuralHoles</code>: fixed calculation of mutual weight:
	<ul>
	<li/>Edges are now no longer required to be either undirected or reciprocated.
	<li/>Nonexistent edges are now treated (for weight calculation purposes) as equivalent
	to edges of weight 0.
	<li/>An exception is no longer thrown if the mutual weight of a vertex with itself
	is asked for.  (Instead, 0 is returned.)
	</ul>
<br>Also edited documentation to emphasize that all edges must have non-null assigned weights.
</ul>

<hr/>

<h3>1.7.2 (Veterans' Day/Remembrance Day 2005)</h3>

<p><b>New Features</b>
<ul>
<li/><code>GraphEditorDemo</code> is a new demo that shows how to create a graph interactively using 
mouse events.  New classes to support this demo are <code>EditingGraphMousePlugin</code> and 
<code>EditingModalGraphMouse</code>.
<li/>The details of controlling view, layout, and crossover scaling are now delegated to 
implementations of the new <code>ScalingControl</code> interface; for example, the
<code>CrossoverScalingControl</code> class now handles the internal crossover
scaling work done in the <code>CrossoverScalingGraphMousePlugin</code>.  They may also be used
to handle scaling control in the action listeners for zoom buttons or keyboard events, and all 
demos have been updated to do so.
This should make it easier for users to create their own scaling controls.
</ul>

<p><b>Changes</b>
<ul>
<li/>Made the default lens size larger in <code>HyperbolicTransformer</code>.
<li/><code>AbstractLayout</code>: 
	<ul>
	<li/>The order of the calls to <code>initialize_local()</code> 
and <code>initializeLocations()</code> is now the same in both <code>restart()</code> and 
<code>initialize()</code> methods: the order is now, in each case, <code>initialize_local()</code> followed by
<code>initializeLocations()</code>.  (Previously, <code>restart()</code> and <code>initialize()</code>
had not called these methods in the same order.)
	<li/><code>initialize_local</code> has been changed to be a 
non-abstract stub method, rather than an abstract method.
	</ul>
<li/>Documentation changed for the <code>restart()</code> method in <code>Layout</code> and 
<code>AbstractLayout</code>. This method is no longer specified to scramble the graph, but to restore
the vertices' initial locations according to the <code>VertexLocationFuction</code> specified at 
initialization (which may have been randomly generated). 
To generate new initial random locations, users may call 
<code>layout.initialize(layout.getCurrentSize())</code> instead.
</ul>
<p>
<p><b>Bug Fixes</b>
<ul>
<li/><code>ShapePickSupport</code> constructor changed to actually set the passed
<code>layoutTransformer</code> reference. This bug affected no existing code, as
the <code>setLayoutTransformer</code> method is called by <code>VisualizationViewer</code> 
when the <code>vv.setPickSupport(pickSupport)</code> is called, if <code>pickSupport</code> 
is an instance of <code>ShapePickSupport</code>.
<li/><code>VertexIconAndShapeFunction</code> <code>getShape(Vertex v)</code> method:
First line expression changed from <code>(Icon)iconMap.get(v)</code> to <code>getIcon(v)</code> so that
subclasses could more easily override the behavior.
<li/>Moved <code>event.consume()</code> call to inside of modifier test conditional in 
<code>AnimatingPickingGraphMousePlugin</code>.
<li/>Changed <code>DefaultModalGraphMouse</code> creating of JComboBox so that current mode is
always selected on creation of mode combo box.
<li/><code>EdgeShape</code> modified so that the edge shapes that allow parallel edges 
also enable parallel self-loops (this restores the behavior that existed in 1.6.0).
<code>CubicCurve</code> now also properly uses the static loop instance to draw self-loops.
<li/><code>SatelliteRotatingGraphMousePlugin</code> and <code>SatelliteShearingGraphMousePlugin</code>
modified to correct the center of rotation and shear for the <code>SatelliteVisualizationViewer</code>.
<li/>Changed <code>setGraphLayout(Layout layout, Dimension viewSize)</code> method in class
<code>DefaultVisualizationModel</code> to call either <code>initialize(Dimension d)</code>
or <code>restart()</code>, but never both.
</ul>

<hr/>

<h3>1.7.1 (US National Mole Day 2005)</h3>
<p><b>Changes</b>
<ul>
<li/><code>KKLayout</code> now
  <ul>
  <li/>takes an optional <code>Distance</code> parameter as its means of
  measuring distances between vertices.  This means that users can base the 
  algorithm on weighted or unweighted network distances, or even distances that have nothing to 
  do with the network topology at all.
  <li/>supports graphs with directed edges: <code>KKLayout</code> now uses the minimum of the
  a->b and b->a shortest path lengths as its canonical a-b "distance".
  <li/>stores distances internally using a <code>double[][]</code> array, rather than
  a <code>DoubleMatrix2D</code>; this should reduce the memory footprint somewhat.
  <li/>allows the user to specify a "length factor" which partially determines the "preferred"
  length of the edges (in conjunction with the size of the window and the diameter of the network).
  <li/>allows the user to specify a "disconnected distance multiplier" which specifies the fraction
  of the graph's diameter to use as the distance between disconnected vertices.
  <br>The above two parameters can be used to control the amount of the screen that the graph 
  occupies, and thus to ensure that disconnected components are not drawn offscreen.
  </ul>
<li/><code>FRLayout</code> now has two settable parameters that specify the multiplicative factors
used to calculate vertex repulsion and attraction.  (Previously these two factors were the same,
and were not user-settable.)
<li/>New Interfaces added: <code>LayoutTransformer</code> and <code>ViewTransformer</code> 
provide methods to map points from layout to screen 
coordinate systems, and from screen to layout coordinates.
<li/>VisualizationViewer</code> now declares that it implements <code>Transformer</code>, 
<code>LayoutTransformer</code>, and 
<code>ViewTransformer</code>. There are no new methods added; the new interfaces' contracts are satisfied
with existing <code>VisualizationViewer</code> methods.
<li/><code>PickedState</code> now implements <code>ItemSelectable. MultiPickedState</code>
accepts <code>ItemListeners</code> and fires <code>ItemEvents</code> when the picked vertices and
edges change. <code>PickEventListener</code> has been deprecated and its functionality replaced by 
<code>ItemListener</code>.
<li/><code>ShapePickSupport</code> has been internally modified to use a <code>LayoutTransformer</code> 
to assist with picking. Users may not notice this change, as the <code>LayoutTransformer</code> is normally 
set by the <code>VisualizationViewer</code> during its <code>setPickSupport(PickSupport ps)</code> method.
<li/><code>PajekNetReader</code> now throws an exception if it encounters an edge type that is not
supported by the type of the supplied graph (e.g., it throws if it encounters an "*Edges" section and the graph only 
accepts directed edges).  (Previously, it had simply ignored such incompatible edges, which occasionally
resulted in an unexpectedly empty graph with no explanation.)
<li/>Changed the declared plugins in <code>DefaultModalGraphMouse</code> to the more general 
<code>GraphMousePlugin</code> type.
<li/>Added <code>{get, set}Delegate()</code> methods to <code>LayoutDecorator</code>.
<li/>The <code>ShowLayouts</code> demo now allows the user to select any of several different graphs for
display; this makes it easier for users to evaluate the fitness of each layout algorithm for their purpose.
</ul>

<p><b>Bug Fixes</b>
<ul>
<li/><code>DefaultVisualizationModel.stop</code>: wrapped the call to <code>relaxer.interrupt()</code>
in a try-catch block to sidestep an applet security violation problem.
<li/><code>GradientEdgePaintFunction</code> now takes a <code>LayoutTransformer</code> in its constructor.
The <code>LayoutTransformer</code> is used to propery apply the gradient at the endpoints of the edges.
<li/><code>TranslatingGraphMousePlugin</code> modified so that the graph element translation remains
coincident with the mouse pointer at extreme zoom-out values.
<li/><code>MultiPickedState</code> was modified so that it only fires events when the picked state
actually changes. This will prevent its participation in an infinite loop of pick related events.
<li/><code>PajekNetReader</code> now no longer throws an exception when given input that has no 
vertex labels.
<li/>Fixed bug in <code>SatelliteCrossoverScalingGraphPlugin</code> that caused improper crossover behavior.
<li/><code>SpringLayout</code>: removed incorrect division of "stretch" by 100, which caused the edges'
"springs" to be too weak (leading to a disorganized and chaotic visualization).

</ul>

</ul>

<hr/>

<h3>1.7.0 (Autumnal Equinox 2005)</h3>
<p><b>New Features</b>
</p>
<ul>
  <h4>Visualization Architecture Improvements</h4>
  <p>Tom Nelson has once again done (a) great (deal of) work on the visualization architecture.
  New and continuing JUNG users may want to take a look at the new short guide
  <a href="http://jung.sourceforge.net/doc/JUNGVisualizationGuide.html">"Understanding
  the JUNG Visualization System"</a> (written primarily by Danyel Fisher) to get an 
  overview of the entire architecture as it currently
  stands, and tips for using it.</p>
  <li/><b>The class called <code>GraphDraw</code> has been deprecated.</b>  See the aforementioned
  Visualization Guide for pointers on how to create JUNG visualizations using 
  <code>VisualizationViewer</code> directly.
  <li/><code>Transformers</code>
  <ul>
  	<li/>Transformations of the Graph are handled by implementations of the <code>Transformer</code> interface. Available transformations include:
  	<ul>
  	<li/>scaling
  	<li/>translating
  	<li/>rotating
  	<li/>shearing
  	<li/>hyperbolic projection
  	</ul>
    <li/>Graphs can now be scaled in two ways:
    <ul>
      <li/>view - a scaling transform is applied to the graphics context so that vertices and labels change size as the graph changes size
      <li/>layout - a scaling transform is applied as a filter to the Layout so that vertices and labels stay the same size and their locations zoom in and out
    </ul>
    <li/>The supplied mouse listener classes allow access to both kinds of scaling. Additionally, there is a mouse listener class <code>CrossoverScalingGraphMousePlugin</code> that changes from layout scaling when you zoom in, to view scaling when you zoom out. This preserves the look of the graph as it gets very small.
    
  </ul>
  <li/><code>DefaultGraphLabelRenderer</code>
  <ul>
    <li/>All <code>Vertex</code> and <code>Edge</code> labels are now drawn with a <code>CellRenderer</code> component, just like <code>javax.swing.JTree</code> and <code>javax.swing.JTable</code> use.
    <li/>This allows the use of html for multi-line, multi-color, multi-font, multi-language labels.
    <li/>Edge labels are now drawn parallel to the edge itself by default. For parallel edges, the labels are offset vertically so they do not overlap. This behavior can be controlled thru a property of the <code>DefaultGraphLabelRenderer</code> class which has a <code>setRotateEdgeLabels(boolean)</code> and <code>isRotateEdgeLabels()</code> method. See it demonstrated in the EdgeLabelDemo.
    
 </ul>
 <li/><code>VertexIconFunction</code>
 <ul>
    <li/>Allows you to use an Icon to represent a Vertex.
    <li/>see  <code>UnicodeLabelDemo</code> and the <code>ImageShaperDemo</code> for examples.
    <li/>The <code>ImageShaperDemo</code> also uses the <code>FourPassImageShaper</code> to return only the outline of the opaque part of a transparent image in order that the picking and the edge arrow placement conforms to the exact shape of the non-rectangular image.
    
  </ul>
  <li/><code>VisualizationViewer</code> refactoring
  <ul>
    <li/><code>VisualizationModel</code> interface represents the state of the <code>VisualizationViewer</code>
    <li/><code>DefaultVisualizationModel</code> class holds the values for the state of the <code>VisualizationViewer</code>
    <li/>Separation of the model from the view will make it easier to show multiple views of one graph. See <code>MultiViewDemo</code> and <code>TwoModelDemo</code>.
	<li/>double buffering
  	<ul>
    <li/><code>VisualizationViewer</code> can use double buffering, painting the graph to an offscreen image then blitting the image to the Window.
    <li/>Double buffering was the default in version 1.6.0. DoubleBuffering is an option in version 1.7 and the default setting is <i>off</i>.
  	</ul>
	</ul>
  <li/><code>VertexLocationFunction</code> is a new interface with two methods: 
  	<code>Point2D getLocation(ArchetypeVertex)</code> and
  	<code>Iterator getVertexIterator()</code>: 
  	<ul>
  	<li/><code>Layout</code> now extends this interface; this gives users a more efficient way of fetching vertex
  	locations (than <code>getX</code> and <code>getY</code>.
  	<li/><code>AbstractLayout.initialize()</code>  
  	now has an optional <code>VertexLocationFunction</code> parameter that allows the user to 
  	specify a set of (initial) locations for the vertices:
  		<ul>
  		<li/>Since <code>Layouts</code> are also <code>VertexLocationFunction</code> instances,
  		this allows users to "chain" layouts together (that is, to use the existing locations specified
  		by one <code>Layout</code> as the input to another).
  		<li/><code>PajekNetReader</code> and <code>PajekNetWriter</code> now include optional parameters to
  		read coordinate information from a Pajek-formatted file and store it in a 
  		<code>VertexLocationFunction</code> instance (and vice versa).
  		</ul>
  	<li/><code>StaticLayout</code> is a new subclass of <code>AbstractLayout</code> that does not alter
  	the locations specified to it on input; this is useful for users that already have an existing layout
  	(with known locations) that they like.
  	<li/><code>SettableVertexLocationFunction</code> extends this interface to include
  	a method <code>setLocation(ArchetypeVertex, Point2D)</code>; <code>DefaultSettableVertexLocationFunction</code>
  	provides a default implementation of this interface.
  	</ul>
  <li/><code>VertexShapeFactory</code> now provides shapes that are cached singletons.
  <ul>
    <li/>should improve performance, particularly in large graphs, as far fewer new Objects are created
    <li/><code>Edge</code> shapes were already cached in version 1.6.0
  </ul>
  <li/><code>HasShapeFunctions</code> interface implemented by <code>PluggableRenderer</code>.
  <ul>
    <li/>has two methods:
    <ul>
      <li/><code>VertexShapeFunction getVertexShapeFunction()</code>
      <li/><code>EdgeShapeFunction getEdgeShapeFunction()</code>
    </ul>
  </ul>
  <ul>
    <li/>Used by <code>ShapePickSupport</code> to supply exact shape definitions for picking with the mouse.
    
  </ul>
  <li/><code>PluggableGraphMouse</code> provides a means to add from a set of supplied <code>GraphMousePlugin</code> instances, or develop your own. The supplied <code>GraphMousePlugin</code> classes provide picking, translating, scaling (layout or view), rotating, and shearing. All are configurable as to the mouse event modifiers that will activate them. The <code>ZoomPanGraphMouse</code> is re-implemented to use <code>PluggableGraphMouse</code> with appropriate plugins. The <code>DefaultModalGraphMouse</code> uses all of the supplied plugins in a configuration intended to follow mainstream applications.
  <li/><code>ModalGraphMouse</code> has two modes: TRANSFORMING and PICKING. Switching between modes allows a better choice of mouse buttons and modifiers for both the picking and transforming mode.
  
  <li/><code>Coordinates</code> is now a subclass of <code>java.awt.geom.Point2D.Float</code>
  <ul>
    <li/>improves efficiency of transform code without breaking legacy use of <code>Coordinates</code> class<br>
    
  </ul>
  <li/><code>BirdsEyeVisualizationViewer</code> has been deprecated and replaced with <code>SatelliteVisualizationViewer</code>. The latter provides a much improved representation of all of the new transforms that can be applied to your graph. See <code>SatelliteViewerDemo</code> as an example.
  <li/><code>TreeLayout</code>, contributed in the support list by Toni Karlheinz, has been included. See <code>TreeLayoutDemo</code> for an example of its use.
  <p>
  <h4>Hypergraphs</h4>
  <br>Hypergraphs are a generalization of undirected graphs in which hyperedges connect
  sets (rather than pairs) of (hyper)vertices; this is a natural representation for affiliations
  and groupwise (rather than pairwise) interactions, such as meetings and multiparty 
  collaborations.  JUNG has for some time included a prototype 
  version of hypergraph support based on <code>BipartiteGraph</code> and related classes.  
  JUNG now provides "native" implementations of <code>Hypergraph</code>, 
  <code>Hyperedge</code>, and <code>Hypervertex</code>, as well as some new capabilities.
  <li/>Hyperedges are created as empty sets of vertices; hyperedges and hypervertices
  may be connected using <code>Hypervertex.connectEdge</code> or 
  <code>Hyperedge.connectVertex</code> (equivalent operations).  However, 
  "orphaned" hyperedges and hypervertices (those that are not elements of 
  existing graphs) may not be connected, and hyperedges/vertices that are 
  removed from a graph are automatically disconnected from all incident
  hypervertices/hyperedges.
  	<li/>Implementations
  		<br>Generally, a <code>Hypergraph</code> is a set of hyperedges and hypervertices
  		with certain operations defined on it.  Currently we have one implementation of
  		<code>Hypergraph</code>: <code>SetHypergraph</code>.
  		<ul>
  		<li/>Hypervertices and hyperedges are duals of one another: hyperedges are connected
  		to sets of hypervertices, and vice versa.
  		<li/>We provide several implementations of hyperedges and hypervertices:
  			<ul>
  			<li/><code>AbstractHyper{vertex,edge}</code> define most of the functionality
  			of the types, but do not specify storage.  (All implementations of 
  			<code>Archetype{Vertex,Edge}</code> must prevent duplicates in their internal 
  			data structures, but internally they need not use <code>Set</code>s for this
  			storage.)
  			<li/><code>CollectionHyper{vertex,edge}</code> are abstract subclasses of 
  			<code>AbstractHyper{vertex,edge}</code> that specify a <code>Collection</code>
  			as the type of storage. 
  			<li/><code>ListHyper{vertex,edge}</code> are subclasses of 
  			<code>CollectionHyper{vertex,edge}</code> that use space-efficient <code>List</code> instances
  			to store their incident elements; they have O(d) time complexity for query operations
  			such as <code>isIncident</code>, where d is the size of the incident element collection.
  			<li/><code>SetHyper{vertex,edge}</code> are subclasses of 
  			<code>CollectionHyper{vertex,edge}</code> that use <code>Set</code> instances
  			to store their incident elements; they require more space than the 
  			<code>ListHyper{vertex,edge}</code> classes, but have expected O(1) time complexity 
  			for query operations.
  			</ul>
  		<li/>Note: nothing prevents users from creating Map-based implementations of hyperedges
  		and hypervertices that are analogous to the Map-based implementations of edges and
  		vertices that JUNG already provides (that is, that represent a hypervertex's incident and 
  		adjacent elements internally as a Map from adjacent vertices to the corresponding connecting
  		edge set).  However, users are cautioned that such an implementation, while it would make 
  		the <code>findEdge[Set]</code> operations efficient, would be expensive in terms of space:
  		the storage required would be equivalent to maintaining a clique (complete graph) on 
  		the vertices of each hyperedge.
  		</ul>
  <p>
  <h4>Miscellaneous</h4>
  <li/>New package <code>algorithms.metrics</code> contains two new classes: <code>StructuralHoles</code>
  (calculates some of the measures presented in Burt's "Structural Holes") and <code>TriadicCensus</code> (counts the number
  of times that each possible configuration of three vertices appears in a specified graph).
  Thanks to Jasper Voskuilen and Diederik van Liere of the Department of Information and Decision Sciences
  at Erasmus University for their donation of the code on which <code>StructuralHoles</code> is based.
  
  <li/><code>BaryCenter</code> is a new vertex ranking class which ranks vertices based
  on the sum of their shortest path distances.  Contributed by Dan Bolser. 
  <li/><code>Element</code> now has a new method <code>getIncidentElements</code>.
  This allows an element to access its incident elements even if its subtype 
  (vertex or edge) is not known; this is useful in the context of hypergraphs, 
  since vertices and hyperedges in a hypergraph are duals of one another 
  and can be treated in some ways equivalently. 
  <li/><code>HypergraphReader</code> creates a <code>Hypergraph</code> based on a 
  <code>Reader</code> whose format is similar to that of <code>BipartiteGraphReader</code>.
  
  <li/>The <code>Distance</code> methods now take <code>ArchetypeVertex</code> 
  arguments rather than <code>Vertex</code>.  This applies to all implementations of
  <code>Distance</code>, including <code>UnweightedShortestPath</code>.  However,
  <code>UnweightedShortestPath</code> still only works on <code>Graph</code> instances
  (for now).
  <li/><code>ShortestPath</code> is now an interface; the <code>getPath</code> 
  method has been refactored into a static method in the new <code>ShortestPathUtils</code> class.
  <li/><code>DijkstraShortestPath</code> has been refactored into two classes: 
  <code>DijkstraDistance</code> (which implements <code>Distance</code>) and 
  <code>DijkstraShortestPath</code>, which extends <code>DijkstraShortestPath</code>
  and implements <code>ShortestPath</code>.  For users of <code>DijkstraShortestPath</code>,
  this change is transparent, but has the following ramifications:
  	<ul>
  	<li/><code>DijkstraDistance</code> functions on all graph types, including hypergraphs.
  	<li/>If all you want to calculate are distances (that is, you don't need the actual paths), 
  	<code>DijkstraDistance</code> is more time- and space-efficient.
  	<li/><code>DijkstraShortestPath</code> stores the "incoming edge" map information as before,
  	for all graph types.  However, the <code>ShortestPathUtils.getPath</code> method will only
  	work on incoming edge maps that contain <code>Edge</code> instances.  (Getting "the other end"
  	of an edge only works on edges with exactly two vertices.)
  	</ul>
  	In addition, <code>Dijkstra*</code> now has the following additional capabilities:
  	<ul>
  	<li/><code>getDistanceMap(ArchetypeVertex, Set)</code> calculates the distance to each 
  	element of the <code>Set</code>.  <i>The user is responsible for ensuring that each of these
  	"target" vertices is an element of the graph specified in the constructor</i>; this method
  	will not validate the targets.
  	<li/><code>setMaxDistance(double)</code>: after a vertex is discovered whose distance from
  	the source is at least this value, no further distances will be calculated. 
  	<li/><code>setMaxTargets(int)</code>: after distances to this many "target" vertices have
  	been calculated, no further distances will be calculated.
  	</ul>
  <li/>New <code>GraphUtils</code> methods:
  	<ul>
  	<li/><code>{add,remove}{Vertices,Edges}({Graph,Hypergraph}, Set)</code>
  		<br>syntactic sugar for repeated calls to <code>g.{add,remove}{Vertex,Edge}</code>
  	<li/><code>vertexMapToDAL</code>: converts Maps of vertices to Number values
	to a <code>DoubleArrayList</code> using a specified Indexer to determine where to put
	the value for a given vertex. This makes it easier for users to apply CERN Colt statistical
	routines (see cern.jet.stat) to JUNG vertex-value maps.  (See the changes to <code>GraphStatistics</code>
	for an example; the new methods return vertex-value maps rather than DALs.)
  	<li/><code>copyValues(ArchetypeGraph g, NumberVertexValue src, NumberVertexValue dst)</code>
  		<br>for each vertex in g, reads values from src and writes them to dst
	<li/><code>getVertexGenerator(ArchetypeGraph)</code>
		<br>Returns the <code>VertexGenerator</code>, if any, stored in the graph's
		user data at the standardized location specified by the VG interface: <code>VertexGenerator.TAG</code>.
  	</ul>
  <li/><code>PredicateUtils</code>: new method 
  	<code>getSatisfyingElements(Collection, Predicate)</code>
  <li/><code>KPartiteFolder</code> has been renamed to <code>FoldingTransformer</code>, and several
  other changes have been made as well:
  	<ul>
  	<li/>Methods for folding instances of <code>Hypergraph</code> are now also provided.
  	<li/>The folding methods now have the option of decorating the edges in the new graph
  	with the number of paths in the original graph that they represent.
  	<li/>Parallel edges in the input graph are no longer specifically prohibited, 
  	but they are ignored.
  	</ul>
  <li/>The <code>UserData</code> architecture has been modified:
     <ul>
     <li/><code>UserDataFactory</code> is a new class with a single method, <code>getInstance</code>,
     which returns a <code>UserDataContainer</code> instance.  Used by <code>UserDataDelegate</code>
     (see below).
     <li/>The graph, vertex, and edge classes now extend the new class <code>UserDataDelegate</code>,
     rather than <code>UserData</code>.
     The purpose of this new class is to allow users to specify their own implementations of
     the <code>UserDataContainer</code> interface; this can be done on an object-by-object basis.
     <code>UserDataDelegate</code> has a static method called <code>setUserDataFactory</code>,
     which specifies the <code>UserDataFactory</code> to use to get a <code>UserDataContainer</code>
     instance for each vertex/edge/graph as it is created.
     <li/>The available implementations of <code>UserDataContainer</code> now include the following, each of
     which implements <code>UserDataFactory</code>:
     	<ul>
     	<li/><code>DefaultUserData</code>: this is the original JUNG implementation, in which each vertex, edge,
     	and graph maintains a separate HashMap which maps keys to (value, copy action) pairs.
     	Straightforward and time-efficient (all operations are O(1) except for <code>importUserData</code>,
     	which requires O(d) time, where d is the number of data to import), 
     	but requires a fair amount of space overhead (O(N) maps, where N is the number of vertices, edges, and
     	graphs in use).  
    	<li/><code>UnifiedUserData</code>: this is a new implementation which maintains a single Map
    	of key values to Maps from vertices/edges/graphs to (value, copy action) pairs.  This implementation
    	is time efficient except for <code>getUserDatumKeyIterator</code>, which requires O(k) time
    	(where k is the number of keys in use) and for <code>importUserData</code>, which requires O(k + d) time.
    	However, it requires much less space overhead (O(k) maps).
    	<br>
   		<b>Warning</b>: this implementation has not yet been extensively unit tested, although it has been used
   		in a number of experiments on very large data sets.  Also, since vertex and edges that are equal
   		to one another (copies) have the same hash code, all copies of a single element will have the same
   		user data repository.  As such, this implementation, as it currently stands, may not be suitable for
   		all applications.
	    </ul>
	 <li/><code>UserData</code> is now primarily an auxiliary class which contains the SHARED, REMOVE, and
	 CLONE <code>CopyAction</code> singleton instances.
	 <li/><code>UserDataContainer</code> now implements <code>Cloneable</code>; implementations must provide
	 a public <code>clone</code> method.
     </ul>
	<li/><code>GraphMatrixOperations</code> now has a few new options for converting Colt matrices
	to JUNG <code>Graph</code> objects and vice versa; among other things, edge weights may now be specified using
	<code>NumberEdgeValue</code> instances.
	<li/><code>BarabasiAlbertGenerator</code> now optionally produces a directed graph.  (The default remains
	an undirected graph.)
  <li/>New interface <code>ParallelEdgeIndexFunction</code> and implementations <code>ParallelEdgeIndexSingleton</code>
  and <code>DefaultParallelEdgeIndexFunction</code> are now used in the visualization code (and may be used elsewhere)
  to define a consistent 0-based index.  <code>PluggableRenderer</code> now has a
  way to plug implementations of this interface in; these classes are used by PR to order parallel edges for 
  consistent rendering.  User implementations may generate indices on any desired basis (lexicographic ordering
  based on edge labels, properties of edges, creation ordering, etc.).
  <li/>All the various experimental database code in the <code>scratch.danyel.db</code> and
  <code>scratch.dawit.db</code> packages has been moved to a new project in the CVS, <cod?>JUNG-DB</code>. We encourage
  you to use these as starting points in building database-backed JUNG projects.
  (And let us know what you come up with!)
</ul>
<p><b>Changes</b>
</p>
<ul>
  <li/><code>ArchetypeGraph.remove{Vertices,Edges}(Set)</code> have been tentatively deprecated in favor
  of the new removal methods added to <code>GraphUtils</code> (see above).  This is part of an ongoing
  investigation into the possible simplification of the JUNG interfaces.
  <li/><code>ErdosRenyiGenerator</code> and <code>DegreeDistributionRanker</code> have been cleaned 
  up a bit and are now slightly more efficient.
  Thanks to Dirk Koschuetzki for the suggestions.
  <li/><code>Indexer</code> now stores its vertex-to-index information using an array
  rather than a Map, which increases both time and space efficiency.  Thanks to Dirk for
  the suggestion.
  <li/><code>VertexStringer</code> and <code>EdgeStringer</code>: the <code>getLabel</code>
  signature now specifies <code>Archetype{Vertex,Edge}</code>, i.e., these now work on any
  kind of vertex and edge, respectively.
  <li/><code>VoltageClusterer</code> and <code>KMeansClusterer</code> now use the CERN Colt
  random number generator, and allow the setting of the random seed.
  <li/>The graph clustering class method signatures now specify <code>ArchetypeGraph</code>
  rather than <code>Graph</code>: specifically, <code>GraphClusterer.extract</code>'s argument, 
  the constructor argument for <code>ClusterSet</code>, and the return value for 
  <code>ClusterSet.getUnderlyingGraph</code> are now all of type <code>ArchetypeGraph</code>. 
  Also, <code>WeakComponentClusterer</code> can now operate on any <code>ArchetypeGraph</code>.
  <li/><code>PajekNetReader</code> now has a new constructor which allows the user to specify
  a <code>VertexGenerator</code> that will be used to create the vertices.
  <li/><code>GraphStatistics</code>: 
  	<ul>
  	<li/><code>clusteringCoefficients</code> and <code>averageDistances</code> now 
  	return their results in the form of a <code>Map</code>
  	from vertices to the corresponding values (coefficients or average distances).  
  	(Previously these results were returned in 
  	<code>DoubleArrayList</code>s, which made it impossible to reliably associate vertices 
  	and their values.)
  	<li/><code>averageDistances</code> and <code>diameter</code> now have an optional 
  	<code>Distance</code> parameter which specifies the distance metric to use in 
  	calculating the results. 
  	<li/><code>diameter</code> now returns <code>Double.POSITIVE_INFINITY</code> if the
  	graph is disconnected (that is, if there exists at least one pair of vertices 
  	<code>(a,b)</code> for which no a-b path exists).  Similarly, <code>averageDistances</code>
  	stores a value of infinity if not all vertices are reachable from the specified vertex.
  	<li/>now operates on <code>ArchetypeGraph</code> instances. 
  	</ul>
</ul>
<p><b>Bug Fixes</b>
</p>
<ul>
  <li/><code>MultiPickedState</code>: fixed bug in pick(ArchetypeEdge, boolean) [was
looking at vertices rather than edges]
  <li/><code>UnweightedShortestPath</code>: fixed bug inside
getShortestPathsFromSource which failed on disconnected graphs
  <li/><code>Pair.equals</code> and <code>AbstractArchetypeVertex.equals</code> 
  now each check for reference equality (==) as well as <code>Object.equals</code>.
  (Previously, for an orphaned <code>ArchetypeVertex</code> <code>v</code>, 
  <code>v.equals(v)</code> would return false, and would therefore, among other things,
  be useless as a hash key.)
  <li/>Several broken and outdated links have been cleaned up in the 
  <a href="http://jung.sourceforge.net/doc/manual.html">JUNG manual</a>.
  <li/><code>EdgeWeightLabeller.getWeight</code> now internally casts EWL's stored values to
  a <code>Number</code> rather than an <code>Integer</code>, so that if its <code>setNumber</code>
  method is used to store non-Integers, it will not throw a <code>ClassCastException</code>.
</ul>
<hr>
<h3>1.6 (April Fools'/Earth Day 2005)</h3>
<p><b>Announcement</b>: Tom Nelson and Jens Krefeldt have joined the
JUNG development team; Tom has been doing a lot of work on the
visualization system, and Jens has contributed a mechanism (not yet
released) for listening to changes to user data
repositories. Welcome!
</p>
<p><b>New Features</b>
</p>
<ul>
  <li/>New decorators and decorator interfaces
    <ul>
      <li/><code>EdgeShapeFunction</code>
        <ul>
          <li/>allows users to specify arbitrary shapes for edges 
          <li/><code>AbstractEdgeShapeFunction</code> provides several
implementations: <code>Line</code>, <code>BentLine</code>, <code>QuadCurve</code>,
            <code>CubicCurve</code>, <code>SimpleLoop</code>, <code>Loop</code>,
and <code>Wedge</code>. All but <code>Line</code>, <code>SimpleLoop</code>,
and <code>Wedge</code> adapt themselves to render parallel edges
distinctly; this makes picking individual edges easier. 
        </ul>
      
      <li/><code>{Vertex,Edge}PaintFunction</code>
        <ul>
          <li/>provide separate methods for specifying draw (outline)
and fill (interior) <code>Paint</code> objects for each vertex/edge;
these are analogous to the "foreground" and "background" colors that
could be specified by <code>VertexColorFunction</code> 
          <li/>replaces (deprecated) <code>{Vertex,Edge}ColorFunction</code>.
Since <code>Paint</code> is a superclass of <code>Color</code>, this
enables use of <code>GradientPaint</code> and <code>TexturePaint</code>,
in addition to <code>Color</code>, to customize vertex and edge
visualizations. (<code>GradientEdgePaintFunction</code> is an example
of this.) 
          <li/>for examples, see the <code>graph.decorators</code>
package, including <code>ConstantVertexPaintFunction</code> and <code>ContantEdgePaintFunction</code>,
as well as <code>PluggableRendererDemo</code>. 
        </ul>
      
      <li/>Three <code>Converter</code> classes have been created to
convert edge color, vertex color, and edge thickness functions to edge
paint, vertex paint, and edge stroke functions respectively. 
    </ul>
  
  <li/><code>PluggableRenderer</code> has been heavily refactored
internally, and has a number of new features; see the revised <code>PluggableRendererDemo</code>
to see them in action. Some of these include:
    <ul>
      <li/>can specify paint functions (see above), which allow for more
flexible visualizations than color functions 
      <li/>can specify edge shapes; see above for examples. The edge
shapes supplied will be scaled in the x-direction to the distance
between the appropriate vertex locations. 
      <li/>arrowheads are now placed at vertex shape boundaries with an
iterative method whose tolerance the user can specify 
      <li/>demonstrates a sample <code>PopupGraphMouse</code> class
that shows popup menus over vertices. 
    </ul>
  
  <li/>Zooming, panning, and scrolling views
    <ul>
      <li/><code>GraphZoomScrollPane</code> is a <code>JScrollPane</code>-like
container for the <code>VisualizationViewer</code>. To use it, simply
pass the <code>GraphDraw</code> or the <code>VisualizationViewer</code>
in the <code>GraphZoomScrollPane</code> constructor, and then add the <code>GraphZoomScrollPane</code>
to your application. The <code>GraphZoomScrollPane</code> scrollbars
automatically update to show the zoom and pan of the graph, and the
scrollbars may be used to pan the graph. For an example, see <code>GraphZoomScrollPaneDemo</code>.
      
      <li/><code>BirdsEyeVisualizationViewer</code> and its <code>Lens</code>,
which facilitate the creation of a separate "zoom" window, have been
enhanced to work better with <code>VisualizationViewer</code>. No
user-code should be required to access the full functionality. See the <code>ZoomDemo</code>
as an example. 
      <li/><code>ZoomPanGraphMouse</code> adds the ability to zoom the
graph with the mouse wheel and pan the graph with a mouse-button-one
drag. A pick-drag on a <code>Vertex</code> will reposition the Vertex.
A pick-drag elsewhere will pan the graph display.
    </ul>
  
  <li/>Vertex and edge picking has been redesigned.
    <ul>
      <li/><code>PickSupport</code> provides a standard interface for
classes that "pick" a vertex or edge based on a specified pick
location, which is typically derived from a mouse event. <code>VisualizationViewer</code>
now uses this mechanism internally. Two implementations are provided: <code>ShapePickSupport</code>
picks only when the mouse point is inside the Vertex shape or when a
small footprint around the mouse point intersects the Edge shape. <code>RadiusPickSupport</code>
picks when the mouse point is 'close enough' to the object; this
corresponds to the former picking behavior that JUNG supplied. 
      <li/><code>PickedState</code> extends the <code>PickedInfo</code>
interface, and provides a standard interface for manipulation of the
"picked" state itself. Implementations can support either single or
multiple picks. Currently one implementation, <code>MultiPickState</code>,
is provided. 
      <li/>The <code>PickEventListener</code> interface may be
implemented by classes that want to register themselves as listeners to
changes to a <code>PickedState instance</code>. <code>PickedState</code>
specifies methods for adding and removing such listeners.
        <ul>
          <li/><code>AbstractLayout</code> now implements <code>PickEventListener</code>.
          
          <li/><code>VisualizationViewer</code> ensures that its
layouts, if they implement <code>PickEventListener</code>, register
themselves as listeners to the existing <code>PickState</code>
instance. However, if the <code>VisualizationViewer</code>'s <code>PickedState</code>
is changed, the listeners must be re-registered with the new <code>PickedState</code>.
        </ul>
      <li/>The renderer and layout interfaces' and classes' methods that
relate to this (for example, <code>Layout.getVertex(x,y)</code>) have
been deprecated and are no longer used internally by JUNG. Layout and
renderer implementations in future will no longer be required to handle
picking directly.
      <li/>The <code>ZoomingPluggableRendererDemo</code> demonstrates a
new variant on picking: you can pick a single vertex with mouse button
one, and add to the selection with mouse button two. Picking with mouse
button two toggles the picked state of the Vertex or Edge that is
picked.
    </ul>
  <li/>Other <code>VisualizationViewer</code> changes
    <ul>
      <li/>You may add pre-render and post render operations to the <code>VisualizationViewer</code>,
using the <code>Paintable</code> interface (a nested interface inside <code>VisualizationViewer</code>).
The methods are <code>{add, remove}PreRenderPaintable(Paintable p)</code>
and <code>{add, remove}PostRenderPaintable(Paintable p)</code>. A user
defined <code>Paintable</code> implementation can be added to the
rendering chain. The <code>Paintable</code> interface also includes a <code>boolean
useTransform()</code> method to allow implementors to specify whether
their <code>Paintable</code> should be transformed by the <code>VisualizationViewer</code>'s
current zoom/pan transform or not. This feature can be used to set a
background image, to place titles, or to overlay custom drawing on the
graph. See <code>GraphZoomScrollPaneDemo</code> for an example that
uses a background image and a foreground title. The <code>ShortestPathDemo</code>
uses a postRenderPaintable to overlay the shortest path on the existing
graph, connecting the path by drawing over the vertices.<br>
      
      <li/>There is now a setter method for the sleep time of <code>VisualizationViewer</code>'s
relaxer thread. 
      <li/>The graph <code>Layout</code> size and the <code>VisualizationViewer</code>
size are independent now. You can initialize the graph <code>Layout</code>
to a large size and the <code>VisualizationViewer</code> will
automatically zoom out to show all of it when you pass the <code>Layout</code>
in the constructor of <code>VisualizationViewer</code>, or when you
call <code>setGraphLayout</code>. 
    </ul>
  
  <li/><code>Element</code> is a new superinterface of <code>ArchetypeVertex</code>
and <code>ArchetypeEdge</code>, and subinterface of <code>UserDataContainer</code>.
This is useful for defining classes or methods (such as decorators)
that can apply to either
vertices or edges. Classes such as <code>AbstractRanker</code> and its
subclasses
have been refactored to use this interface rather than
UserDataContainer.
  
</ul>
<p><b>Changes</b>
</p>
<ul>
  <li/>Some visualization classes originally contributed by Tom Nelson
have now been moved out
of the visualization.contrib package into the main visualization
directory.
  
  <li/><code>GraphDraw</code>:
    <ul>
      <li/>now has a constructor <code>GraphDraw(Layout l)</code> that
allows users to supply their own layout, rather than having to replace
the default layout algorithm (possibly after it had been doing some
computation). 
      <li/>most of its methods (primarily those which were pass-throughs
to <code>VisualizationViewer</code>, the <code>Layout</code>, or the <code>Renderer</code>)
have been deprecated; this is part of an ongoing gradual redesign of
the visualization architecture. See the Javadoc documentation for these
methods for appropriate replacements. 
    </ul>
  
  <li/><code>SubsetManager</code>: changed so that it uses Predicates
internally, not VertexPredicates or EdgePredicates.
  
  <li/><code>KPartiteSparseGraph</code>: added "addallnotinitializers"
code to conversion constructor
  
  <li/><code>EdgeThicknessFunction</code> has been deprecated; use <code>EdgeStrokeFunction</code>
instead.
  
  <li/><code>PluggableRenderer</code>'s control point offset setter has
been removed; the new
version no longer uses it. See <code>EdgeShapeFunction</code> for a
method that allows
the user to set a control point multiplier.
  
  <li/><code>SettableRenderer</code> has been deprecated, and replaced
in JUNG's demos and
sample code by <code>PluggableRenderer</code>.
  
  <li/><code>Layout</code> and subclasses: the <code>wiggleRoom</code>
methods have been removed.
  
  <li/><code>ArrowFactory</code>'s methods now take <code>float</code>
arguments rather than
    <code>int</code> arguments.
  
  <li/><code>EdgeWeightLabeller</code> now implements <code>NumberEdgeValue</code>.
  
</ul>
<p><b>Bug Fixes</b>
</p>
<ul>
  <li/><code>EdmondsKarpMaxFlow</code> now performs sanity checks on its
constructor's inputs
(source and sink must be part of the specified graph, and distinct).
Thanks to Michael Telgkamp for spotting the problem and suggesting the
fix.
  
</ul>
<hr>
<h3>1.5.4 (US National Polar Bear Day 2005)</h3>
<p><b>New Features</b>
</p>
<ul>
  <li/>Several new features in <code>visualization</code>, <code>visualization.contrib</code>,
and <code>samples.graph</code>, courtesy of <a
 href="mailto:tom.nelson@raba.com">Tom Nelson</a>:
    <ul>
      <li/><code>GraphZoomScrollPane</code> implements zooming and
panning using scrollbars; <code>GraphZoomScrollPaneDemo</code>
demonstrates how to use this class. 
      <li/>The <code>Lens</code> class now implements zooming by a
specified percentage value; this capability is reflected in <code>BirdsEyeVisualizationViewer</code>.
      
      <li/><code>PersistentLayoutImpl</code> now supports edge
selection. 
      <li/><code>ZoomDemo</code> has been cleaned up and refactored
somewhat; it now also provides an alternate user interface for zooming
in and out. 
    </ul>
  
</ul>
<p><b>Bug Fixes</b>
</p>
<ul>
  <li/><code>GraphUtils.union</code> now properly copies edges (the edge
iterator
had been iterating over the vertices).
  
  <li/><code>PluggableRenderer</code>'s <code>DOTTED</code> and <code>DASHED</code>
constants redefined to specify a valid value for
the (technically unused) 'mitering' value.
  
  <li/><code>MouseListenerTranslator</code> now properly accounts for
scaling and offset
(zooming and panning) in calculating the location of a mouse click
(also thanks to Tom Nelson).
  
</ul>
<h3>1.5.3 (Christa McAuliffe Day 2005)</h3>
<p><b>Bug Fixes</b>
</p>
<ul>
  <li/><code>PajekNetReader</code> now correctly handles the <code>*Arcslist</code>
and <code>*Edgeslist</code>
tags.
  
  <li/><code>GraphMatrixOperations.matrixToGraph()</code> now works
properly for symmetric
(that is, undirected) graphs: only one edge is created for each
symmetric pair of matrix
entries.
  
  <li/><code>HyperGraphBPG.getUserDatum()</code> now does the right
thing (rather than returning the <code>CopyAction</code> for the
specified key, which is what it was doing).
Thanks to Elwood Johnson for spotting this.
  
</ul>
<p></p>
<p><b>New Features</b>
</p>
<ul>
  <li/><code>PluggableRenderer</code> new capabilities:
    <ul>
      <li/><code>setVertexIncludePredicate</code>: predicate specifies
which vertices are to be drawn 
      <li/><code>setEdgeControlOffsetFunction</code>: value specifies
the control point offset to use to draw the edges; a nonzero offset
causes edges to be drawn as bent lines (otherwise they are drawn as
straight lines). This can be used to distinguish between edge types
(default behavior: directed edges are bent, undirected edges are
straight) or to handle the drawing of parallel edges: if each parallel
edge is given a different control offset, then they won't be drawn on
top of one another. <br>
Side effects of this change:
        <ul>
          <li/><code>PluggableRenderer.CONTROL_OFFSET</code> is no
longer used and has been removed 
          <li/><code>drawDirectedEdge</code> and <code>drawUndirectedEdge</code>
(protected methods) have been replaced by <code>drawSimpleEdge</code>.
          
        </ul>
      
    </ul>
  
  <li/><code>PluggableRendererDemo</code> has been enhanced to
demonstrate
the selective vertex and edge display capabilities. 
</ul>
<p><b>Changes</b>
</p>
<ul>
  <li/><code>EdgeBetweennessClusterer</code> has been altered so that it
no longer operates
on a copy of the graph, but on the graph itself. (The original graph
will be modified
by this algorithm, but will be restored to its original state before
the algorithm
returns.) This should speed up the algorithm somewhat.
  
  <li/><code>ConstantDirectionalEdgeLabelClosenessFunction</code> has
been renamed to the
(fortunately, shorter) <code>ConstantDirectionalEdgeValue</code>,
which better reflects
its generality.
  
</ul>
<hr>
<h3>1.5.2 (Fiesta de Nuestra Se&ntilde;ora de Guadalupe 2004)</h3>
<b>Note</b>: several users have recently had difficulty in acquiring a
copy of
Colt 1.2.0, for use with JUNG 1.5.x. We have made a mirror of the Colt
zip file
available as one of the releases on our SourceForge website.
<p><b>Bug Fixes</b>
</p>
<ul>
  <li/><code>GraphDraw.getRender()</code>, which returns the default
renderer, has been deprecated. It is also now declared to return a <code>Renderer</code>
rather than
a <code>SettableRenderer</code>; this may cause compile errors with
user code which assumed that the renderer returned was a <code>SettableRenderer</code>.
    <br>
It has been replaced by <code>getRenderer</code>,
which returns the <code>Renderer</code> that the <code>GraphDraw</code>
instance is currently
using.
  
  <li/><code>BicomponentCluster</code> has been reimplemented, and now
returns the correct biconnected components. (Note that by definition, a
single isolated vertex and two vertices joined by a single edge are
biconnected components; see the Javadoc
documentation for more details.)
  
  <li/><code>PajekNetWriter</code> now breaks lines using <code>Writer.newLine()</code>
instead of the <code>"\n"</code> character, which should make the
output more
portable (and usable by Pajek itself).
  
</ul>
<b>Changes</b>
<ul>
  <li/><code>utils.StringInputStream</code> is deprecated, and no longer
used internally by JUNG. Users are recommended to use <code>StringReader</code>
in its place.
  
  <li/><code>PajekNetReader</code> now ignores (skips) lines consisting
of whitespace.
  
</ul>
<hr>
<h3>1.5.1 (Hannukah 2004)</h3>
<b>Bug Fixes</b>
<ul>
  <li/><code>UserDataContainer.Clone.onCopy()</code>, which is used in
UserData.CLONED, now properly lets objects which <i>inherit</i> a
public <code>clone()</code> method to be cloned. (Previously it only
allowed objects whose classes <i>declared</i> public <code>clone()</code>
methods to be cloned.)
  
  <li/><code>SimpleSparseVertex</code> now removes undirected self-loops
without reporting an error.
  
  <li/>Moved <code>DiscreteDistribution</code> into the release
(package jung.statistics), so that <code>VoltageClusterer</code> and <code>KMeansClusterer</code>
can be compiled and run.
  
</ul>
<b>Changes</b>
<ul>
  <li/><a href="mailto:tom.nelson@raba.com">Tom Nelson</a>'s contributed
code (in <code>jung.visualization.contrib</code>) to provide support
for persistent layout and zooming/panning has evolved somewhat:
    <ul>
      <li/><code>Lens</code>: updates and comments 
      <li/><code>BirdsEyeGraphDraw</code> replaces <code>ReadOnlyGraphDraw.java</code>
      
      <li/><code>BirdsEyeVisualizationViewer</code> replaces <code>ReadOnlyVisualizationViewer</code>
      
    </ul>
These new names are intended to better reflect the functions of the
classes.
The BirdsEyeVisualizationViewer uses a nested class
called Lens to draw the zoom/pan area as a rectangle.
The Lens fires PropertyChangeEvents to cause the main
graph view to zoom and pan.
    <p>Note that BirdsEyeVisualizationViewer has no getLens() method.
The way to add PropertyChangeListeners to the Lens is to add them to
the BirdsEyeVisualizationViewer which will later pass them to the Lens
after the Lens has
been created. This change fixes the NullPointerException that a user
would get if they
attempted to add listeners to the Lens before it was
created.</p>
    <p>In addition, <code>samples.graph.PersistentLayoutAndZoomDemo</code>
has been
replaced by two separate programs: <code>ZoomDemo</code>, which just
shows the zoom/pan feature,
and <code>PersistentLayoutDemo</code>, which shows the persistent
Layout.</p>
  
  <li/>JUNG's Ant build file (<code>build.xml</code>) is now included in
the src/ directory
of <code>jung-#.#.#.zip</code>; this is known to work with Ant version
1.6.2. This may be used to facilitate building your own custom
versions of JUNG.
<!-- IGNORE THIS: PLACEHOLDER FOR FUTURE NOTES
<li/><p>Vertex and edge constraints are now handled slightly differently.  Up to now,
some predicates (such as <code>NotInGraphVertexPredicate</code>) were identified as 
"initialization predicates" via the boolean field <code>GPredicate.isInitializationPredicate</code>; 
constraints with this tag were not copied into a new graph by the <code>copy()</code> or
<code>newInstance()</code> methods.  Also, users had complete access to the vertex/edge
constraint collections, and could remove any constraint at any time (including constraints
automatically added at creation time, whose removal could result in unpredictable behavior).</p> 

<p>As of this version, JUNG now maintains two separate constraint collections for vertices, and
two for edges: the <i>user</i> constraints, and the <i>system</i> constraints.  Vertices and
edges, as they are added, are checked against each element of each of these collections.  <i>User</i>
constraints are accessible, as before, with the <code>get{Vertex,Edge}Constraints()</code>
methods; constraints may be added to these collections (if the graph is non-empty) and 
may be removed from them at any time.  <i>System</i> constraints are only visible and 
modifiable internally (that is, by graph implementations).  Hereafter, the documentation 
for a graph implmentation must specify the constraints that it imposes, and, for each
constraint, whether it is a <i>user</i> constraint (which a user can therefore 
remove) or a <i>system</i> constraint (to which users have no direct access).</p>

<p>The <code>GPredicate</code> abstract class (and the use of its 
<code>isInitializationPredicate</code> field) is now deprecated and no longer used.  
JUNG now uses the tagging interface <code>UncopyablePredicate</code> to identify 
vertex and edge constraints that should not be copied.  Users that create their own 
constraint implementations should note that <code>any graph-specific constraints</code>
(that is, those that relate to a particular graph <code>g</code>) should almost certainly be declared
to implement <code>UncopyablePredicate</code>, because such constraints generally 
don't make sense when applied to vertices and edges which are being added to a graph
other than <code>g</code>.</p> -->
  <li/>JUNG no longer uses the type <code>sun.misc.Queue</code>.
  
</ul>
<hr>
<h3>1.5 (Remembrance Day 2004)</h3>
<p><b>Summary</b>: new visualization features (updated <code>VisualizationViewer</code>,
new <code>PluggableRenderer</code>, and <code>SpringLayout</code> to
make them more flexible and powerful; take a look at <code>PluggableRendererDemo</code>),
new clustering and ranking algorithms, new vertex mapping
mechanisms, new ways of reporting and diagnosing constraint violations,
numerous
new decorators and predicates; a number of improvements in usability
and function to existing classes (including GraphML and Pajek I/O), and
a number of bug fixes,
including extensive revisions to the Barabasi preferential-attachment
graph generator. Also now using COLT 1.2 (whose new license
requirements should free JUNG for use in commercial development) and
Commons-Collections 3.1.</p>
<b>New Features</b>
<ul>
  <li/><code>VisualizationViewer</code>: added contributed code to do
tooltip visualization, zooming/panning, saving layout to a file and
restoring, setting rendering hints (see <code>java.awt.RenderingHints</code>)--which
allows things like antialiasing of text and graphics, as well as other
speed/quality tradeoffs; see <code>visualization.contrib</code> for
related new classes (courtesy of Tom Nelson, RABA Technologies, <a
 href="mailto:tom.nelson@raba.com">tom.nelson@raba.com</a>).
Antialiasing now turned on by default in <code>VisualizationViewer</code>.
  
  <li/><code>PluggableRenderer</code> is the successor to <code>SettableRenderer</code>.
Using the appropriate methods, the user can override the default
properties/behaviors for vertex color, stroke, shape, label, label
font, and label centering; and for edge color, stroke, label, arrows,
label font, and label positioning. These behaviors are generally
controlled by supplying decorators. (in <code>visualization</code>) <br>
    <code>samples.graph.PluggableRendererDemo</code> shows off many of
these functions.
  
  <li/>new decorators: <code>VertexAspectRatioFunction</code>, <code>VertexFontFunction</code>,
    <code>VertexShapeFunction</code>, <code>VertexSizeFunction</code>,
    <code>VertexStrokeFunction</code>; <code>EdgeArrowFunction</code>,
    <code>EdgeFontFunction</code>, <code>EdgeStrokeFunction</code>;
constant implementations of each of these interfaces; <code>ConstantEdgeValue</code>,
    <code>UserDatumNumber{Edge,Vertex}Value</code>, <code>NumberVertexValue</code>,
    <code>Number{Edge,Vertex}ValueStringer</code> (all in <code>graph.decorators</code>)
  
  <li/><code>VertexShapeFactory</code>: a utility class for generating
shapes for drawing vertices. See <code>samples.PluggableRendererDemo</code>
and <code>EllipseVertexShapeFunction</code> for some examples of its
use.
  
  <li/><code>ArrowFactory</code>: generates arrow shapes for use in <code>SettableRenderer</code>.
  
  <li/><code>KMeansClusterer</code>: a utility class for clustering
objects with n-dimensional coordinates according to their proximity to
one another, using the k-means algorithm.
  
  <li/><code>VoltageRanker</code>: ranks vertices in a graph according
to their 'voltage' in an approximate solution to the Kirchoff
equations. This is accomplished by tying "source" vertices to specified
positive voltages, "sink" vertices to 0 Volts, and iteratively updating
the voltage of each other vertex to the (weighted) average of the
voltages of its neighbors.
  
  <li/><code>VoltageClusterer</code>: Clusters vertices of a <code>Graph</code>
based on their ranks as calculated by <code>VoltageRanker</code>.
  
  <li/><code>ConstraintViolation</code>: a new exception type which is
thrown when a vertex or edge which violates a graph's constraints is
added; it provides a method (<code>getViolatedConstraint()</code>)
which returns a reference to the violated constraint, which makes it
easier to diagnose the problem (see new <code>PredicateUtils.evaluateNestedPredicates()</code>
method). Extends <code>IllegalArgumentException</code>. Developers of
graph classes who plan to throw this exception should note that the
violated constraint is a required constructor parameter. 
  <li/><code>PredicateUtils.evaluateNestedPredicates()</code>: returns
the separate results of evaluating the constituent predicates of the
specified predicate, if any, as a Map from predicates to evaluations.
(Some predicates, such as <code>AndPredicate</code>, are <code>PredicateDecorator</code>s,
which operate on other predicates.) This method can be used to
determine which constituent predicates pass/fail for a specified
object, which may be useful for understanding constraint violations.
Note that this method can be used recursively on the constituents of a <code>PredicateDecorator</code>.
  
  <li/><code>GraphUtils.union()</code>: merges two graphs into a single
graph (thanks to Pablo Olmos for the suggestion and for a draft
version)
  
  <li/><code>DirectionTransformer</code> now has a new option to create
new vertices of the correct type rather than copying the old vertices
    <ul>
      <li/>advantage: original vertex type does not have to support
directed &amp; undirected 
      <li/>disadvantages: any class-specific fields won't be copied
(since this mechanism does not use clone()), and vertices in the
transformed graph will not be "equal to" the corresponding vertices in
the original graph 
    </ul>
  
  <li/><code>AbstractRenderer.getPickedKey()</code>: new method that
allows the user to get the user data key that this instance uses to
keep track of selected vertices 
  <li/><code>findEdge[Set]()</code>: this has been a <code>Vertex</code>
method, but it should have been an <code>ArchetypeVertex</code>
method; now, it is. (The <code>Vertex</code> version still exists for
backward compatibility.)
  
  <li/>new predicates: <code>ContainsUserDataKeyVertexPredicate</code>,
    <code>SourceVertexPredicate</code>, <code>SinkVertexPredicate</code>,
    <code>ReciprocatedDirectedEdgePredicate</code>, <code>ThresholdPredicate</code>
(all in the <code>graph.predicates</code> package)
  
  <li/><code>VertexMapper</code> and its implementations (<code>AbstractVertexMapper</code>,
    <code>StringLabellerVertexMapper</code>, and <code>CopyVertexMapper</code>)
provide a general mechanism for defining vertex/vertex mappings. These
do not replace vertex equality as created by <code>ArchetypeVertex.copy</code>,
but rather give a way for mappings to be created that don't depend on
vertex equality. <code>SettableVertexMapper</code> is an interface for
    <code>VertexMapper</code> implementations that allow users to write
the mappings as well as read them; <code>HashSettableVertexMapper</code>
is an implementation of this interface. (<code>utils</code> package) 
</ul>
<b>Changes</b>
<ul>
  <li/>Now using the new version of the COLT library (now 1.2; was
1.0.3); we are told that it no longer uses packages whose licenses that
prohibit commercial use, so JUNG, in turn, should now be available for
commercial use. This involved no user-level changes, but some minor
changes in random number generation and formatted output.
  
  <li/><code>GraphML</code> now writes out mixed-mode graphs (and
properly labels edges of the non-default type as necessary; default for
mixed mode is 'directed'); some minor format issues also cleaned up
(thanks to Pietro Pilolli)
  
  <li/><code>ConnectedGraphPredicate</code> now returns <code>true</code>
on an empty graph (was throwing <code>NullPointerException</code>).
  
  <li/><code>SpringLayout</code>: what were constants (FORCE_CONSTANT,
STRETCH, RANGE) are now documented instance variables with setters and
getters, which allow users to change some aspects of its behavior.
  
  <li/><code>EdgeWeightLabeller</code> default UserData key now has
public (not package) visibility
  
  <li/><code>UnweightedShortestPath</code> now provides <code>reset()</code>
methods which clear out the hash maps that it uses to store the
distances and incoming edge maps.
  
  <li/>moved <code>LeanSparseVertex</code> from <code>samples</code>
to <code>graph.impl</code>; this permits one of the unit tests to
compile properly without the samples directory, and also makes this
class more readily available. <code>LeanSparseVertex</code> is an
alternative to <code>SparseVertex</code> that uses a lighter-weight
internal implementation; it is not as fast as <code>SparseVertex</code>
for some operations, but has less space overhead.
  
  <li/><code>AbstractSparseVertex</code> and subtypes: <code>getEdges_internal()</code>
and <code>getNeighbors_internal()</code> now return a <code>Collection</code>
rather than a <code>Set</code>, which allows for more flexibility in
internal implementations. This involved some signature changes in
vertex implementations, but no changes to signatures of public methods.
  
  <li/><code>PajekNetReader</code>:
    <ul>
      <li/>Removed <code>Collection</code> of edge constraints from
constructor. Edge constraints are now defined implicitly by
(optionally) passing a <code>Graph</code> to the <code>load()</code>
method. The edge data are filtered according to the graph's
constraints, if any; thus, if the graph only accepts directed edges,
any undirected edges in the input are ignored. 
      <li/>Now throws <code>IllegalArgumentException</code> if vertex
numbers are outside of range [1, n], where n is the number of vertices;
had been throwing <code>NullPointerException</code>. Thanks to Dirk
Koschuetzki for the suggestion. 
    </ul>
  
  <li/>Everybody's favorite trivial change: <code>StringLabeller</code>
now implements
    <code>VertexStringer</code>.
  
  <li/><code>TypedVertexGenerator</code> has a new constructor that
takes an <code>ArchetypeGraph</code> and extracts the constraints it
needs from it.
  
  <li/><code>DijkstraShortestPath</code>: now defaults to edge weights
of 1 if no edge values specified; also provides some new constructors.
  
  <li/><code>KPartiteFolder</code> now has a <code>setCopyAction()</code>
method so that users can choose to let <code>FOLDED_DATA</code> be
accessible to copies of the edges (default copy action remains <code>REMOVE</code>)
  
  <li/><code>UserDatum{Edge,Vertex}Predicate</code> now test for
equality with <code>equals()</code> rather than <code>==</code>
  
  <li/><code>EvolvingGraphGenerator.reset()</code> documentation
changed: previously claimed to set |V| and |E| to 0; this doesn't work
for Barabasi generator because it has to start with a seed. Now claims
that it resets this instance to the state it had just after the
constructor had completed.
  
  <li/><code>VertexColorFunction</code>, <code>EdgeColorFunction</code>,
    <code>EdgeThicknessFunction</code> moved from <code>visualization.graphdraw</code>
to <code>graph.decorators</code>
  
  <li/>JUNG now requires version 3.1 of the commons-collections package
(up from
3.0).
  
</ul>
<b>Bug Fixes</b>
<ul>
  <li/><code>GraphMLFileHandler</code>: tag parser now no longer calls <code>toLowerCase()</code>
on output of <code>attrs.getQName()</code>, which caused problems with
saving/restoring a graph (thanks to Damon for spotting this)
  
  <li/><code>VisualizationViewer.prerelax()</code> no longer emits
messages to console
  
  <li/><code>SouthernWomen</code> sample: date format now specifies the
US locale, so the
applet can be run in places where this locale is not the default.
(Thanks to Julien
Kronegg for reporting this.)
  
  <li/><code>BarabasiAlbertGenerator</code>:
    <ul>
      <li/>elapsed time now being calculated properly (had been
incremented twice for the same operation) 
      <li/>now properly disallows self-loops 
      <li/>now properly allows parallel edges 
      <li/>probabilities (and therefore edge attachments) were not being
calculated correctly; now all existing vertices have positive
probability of being connected even if they have degree 0 
      <li/>now has a required parameter that specifies the correct
number of initial "seed" vertices 
    </ul>
  
  <li/><code>AbstractRanker</code>: fixed bug which resulted, for
ranking algorithms that
could rank either vertices, edges, or both (such as <code>BetweennessCentrality</code>),
in the unexpected removal of vertex decorations.
  
  <li/><code>BetweennessCentrality</code>: wasn't re-initializing the
decorations inside computeBetweenness(), so that if the vertex
decorations were still there from a previous run, it would incorporate
those values into the new calculations. This has now been fixed; the
fix adds O(V+E) to the time required for the algorithm, but with the
current <code>AbstractRanker</code> architecture this may not be
avoidable.
  
  <li/><code>PajekNetReader</code>, <code>PajekNetFile</code>: fixed
parsing bug relating to leading space on input lines (input lines are
now run through <code>trim()</code> to remove leading/trailing
whitespace)
  
  <li/><code>SimpleSparseVertex.findEdgeSet()</code> now correctly
returns both directed and undirected edges if both exist (previously
had only been returning one or the other)
  
  <li/>replaced references to <code>biao.net</code> (old filename) with
    <code>simple.net</code>
  
</ul>
<b>Known Issues</b>
<ul>
  <li/><code>GraphStatistics.diameter()</code> returns the largest
*finite* distance
  
  <li/><code>BiComponentCluster</code> appears to be broken (see forum
message from Patrick Godeau) 
  <li/><code>DirectionTransformer</code>: currently ignores parallel
edges, if any; user data importing has some peculiarities (see
documentation)
  
</ul>
<hr>
<h3>1.4.3 (Summer Solstice 2004)</h3>
<b>New Features</b>
<ul>
  <li/>New predicate: <code>ReciprocatedDirectedEdgePredicate</code>
returns <code>true</code>
if its input is a <code>DirectedEdge</code> <code>e1 = &lt;u,v&gt;</code>,
and there exists a <code>DirectedEdge</code> <code>e2 = &lt;v,u&gt;</code>
in the same graph (that is, if there exists
an edge <code>e2</code> such that <code>e1</code>'s source is <code>e2</code>'s
destination and vice versa; such edges are also
known as antiparallel edges).
  
</ul>
<b>Bug Fixes</b>
<ul>
  <li/><code>PajekNet{Reader,Writer}</code> are now actually in the
release, in the
    <code>jung.io</code> package. (This was mentioned in the 1.4.0
release notes (see below), but the files were not actually included in
the collection of those in the release packages.)
  
</ul>
<b>Changes</b>
<ul>
  <li/><code>UserData.addUserDatum()</code> now rejects (with an
IllegalArgumentException) attempts to add user data
whose key value is null. 
  <li/>The website now contains only the most recent version of the
documentation;
browser requests for the old versions are redirected to the most recent
version.
(This is to prevent people accidentally connecting to old versions of
the documentation when they access it via a search engine.) Older
versions of the documentation are still available as one of the release
files for the appropriate
version of JUNG.
  
  <li/>The constructors for <code>{Edge,Vertex}PredicateFilter</code>
each can now take a plain <code>Predicate</code>; this allows these
filters to
accept compound predicates (such as those provided by
commons-collections,
for example: <code>AndPredicate</code>, <code>OrPredicate</code>, and
    <code>NotPredicate</code>).
  
</ul>
<hr>
<h3>1.4.2 (Memorial Day 2004)</h3>
<b>Bug Fixes</b>
<ul>
  <li/>The <code>Simple*SparseVertex</code> classes now properly
prevent parallel edges
from being attached to them.
  
  <li/><code>DirectedSparseVertex.findEdgeSet()</code> had a bug which
has now been fixed;
this had resulted in an error when <code>DirectedSparseVertex</code>
was used in conjunction
with a graph which disallowed parallel edges (such as the default
configuration of <code>DirectedSparseGraph</code>.)
  
  <li/>Alpha-level Prefuse support has graduated to a separate project,
also to be released from
jung.sourceforge.net. This means you don't need an annoying jar just to
compile jung samples.
  
  <li/>Updated SouthernWomenBipartite to use (and thus demonstate) the
new
KPartite infrastructure... It was a little bumpy at first, and 1.4.1
has errors in the transition.
It should be fixed now.
  
  <li/>However, before now, BipartiteGraphReader was producing
BipartiteGraphs that couldn't
be copied, because their userdata fields were not SHARED between
instances. It is now fixed.
  
</ul>
<b>New Features</b>
<ul>
  <li/>StringLabeller and GlobalStringLabeller contain support for
removeLabel, which
removes the label that had been there and returns the corresponding
vertex. This allows
you to set up a new vertex with an old label.
    <pre>		sl.setLabel( v1, "test" );<br>		sl.removeLabel("test");<br>		sl.setLabel( v2, "test" );<br>	</pre>
  
</ul>
<hr>
<h3>1.4.1 (A few days after Cinco de Mayo 2004: bugfixes and memory
leaks)</h3>
<b>Bug fixes: Memory leaks</b>
<ul>
  <li/> Now prevents near-duplicate predicates from being added to the
graph. In the previous version, when a graph was copied, the predicates
it stored were copied--but a new set was created, too, in the
initialize() method. Now predicates
added in "initialize" should be tagged with "isInitializePredicate",
which will prevent them from being copied.
  
  <li/> Filters only keep a copy of their previous graph when assemble(
true ) is
called; the GraphAssemblyRecord is stored in userdata and is set on
REMOVE, so
it is not copied.
  
  <li/> Vertices point to their graphs with a WeakReference. This means
that if
you are in the habit of hanging on to your graphs with just the vertex,
it may
go away on you; on the other hand, a stray vertex (fox example, in the
GlobalStringLabeller) will not keep your graph from being garbage
collected.
  
</ul>
<b>Bug Fixes: GraphDraw</b>
<ul>
  <li/>SpringLayout is now compatible with dynamic graphs.
  
  <li/>Generally, dynamic graphs are better handled within classic
graphdraw:
some functions are now synchronized; and it is now possible to find out
whether
the visrunner thread is running. See samples.addNodeDemo.
  
  <li/> (Minor: Now arrows on self-loops only draw if self-loops are
turned on.)
  
</ul>
<b>New Features</b>
<ul>
  <li/>SparseTree implements a directed, rooted tree: getRoot() returns
the root.
It is implmeneted with constraints; every edge must point from a node
to a node
lower on the tree. Note that the tree allows for single isolated nodes
in the graph; however, edges
must be added DOWN the tree, from root downward.
  
  <li/>Experimental support for creating <a
 href="http://prefuse.sourceforge.net">prefuse</a>
graphs inline is now available. You can create your JUNG graph, filter
and decorate
appropriately, and then use the powerful Prefuse visualization system
to view it. See <code>samples.prefuse</code>
  
</ul>
<b>Gotchas</b>
<ul>
  <li/>Unfortunately, it is entirely too easy to create a predicate that
knows
its own graph. This is a potential problem when you copy the graph and
the
predicate with it--JUNG does not adjust where the "own" pointer
points, so the predicate will be obsolete.
  
</ul>
<hr>
<h3>1.4 (Cinco de Mayo 2004)</h3>
<b>New Features</b>
<ul>
  <li/>Predicates
    <ul>
      <li/>With this release, JUNG introduces the use of <code>Predicates</code>
(a Jakarta Commons-Collections API interface). A <code>Predicate</code>
tests whether an <code>Object</code> satisfies a specific
implementation-defined property. Predicates may be logically combined
using
such Jakarta-defined predicates as <code>AndPredicate</code> (which
returns
true if all input predicates return true).
JUNG uses <code>Predicates</code> (found in the <code>graph.predicates</code>
package) for the following tasks:
        <ul>
          <li/>defining constraints on edges and vertices added to a
graph (=&gt; graphs
that only allow vertices with a certain decoration, or that only allow
directed edges)
          
          <li/>defining/creating edge and vertex subsets (create a
subset of all
vertices with label "student")
          
          <li/>general testing for properties of edges, vertices, and
graphs (is this
graph connected?)
          
        </ul>
      
      <li/><b>Note</b>: Some predicates are unsuitable for use as
constraints
(and some predicates are <i>only</i> suitable for use as constraints).
We have tried to make these distinctions clear in the documentation for
each predicate. Users are strongly advised to read the documentation
for a predicate before using it.
      
      <li/>For more information on <code>Predicates</code> and their
use, see
        <a
 href="http://jakarta.apache.org/commons/collections/apidocs/org/apache/commons/collections/Predicate.html">the
commons-collections website</a> and the package documentation for the <code>predicates</code>
package.
      
    </ul>
  
  <li/>Constraints
    <ul>
      <li/>Graph classes (implementations of ArchetypeGraph) now provide
mechanisms for maintaining constraints on vertices and edges, each of
which are specified by user-supplied criteria. Constraints specified
must be satisfied by each vertex or edge added to the graph.
        <br>
Thus, for example, a user can now create a k-partite graph (which
consists of k disjoint sets of vertices, such that each edge connects
vertices from distinct partitions; a bipartite graph is a 2-partite
graph) by starting with a <code>SparseGraph</code> and adding
specifications for vertex subsets (see Subsets/Partitions, below) and
edge constraints. 
      <li/>Specifications for edge types that graphs can accept (e.g.,
undirected, directed, parallel) are now implemented in terms of these
constraints.
As a consequence, JUNG now supports <b>mixed-mode graphs</b> (graphs
which contain both directed and undirected edges) and <b>graphs with
parallel edges (also known
as <i>multigraphs</i>)</b>.
        <br>
Two distinct edges are considered to be <i>parallel</i> to one another
if the following conditions hold:
        <ul>
          <li/>the edges are both directed or both undirected
          
          <li/>if undirected, the incident vertex sets for each edge are
the same
          
          <li/>if directed, the edges each have the same source vertex
and the same
destination vertex
          
        </ul>
      
      <li/><code>SparseGraph</code>: new extension of
AbstractSparseGraph, which, by default, imposes no constraints on its
vertex and edge sets; it allows directed, undirected, and parallel
edges.
      
      <li/><code>KPartiteGraph</code>: an interface which extends <code>Graph</code>,
implementations of which must be k-partite graphs. (k-partite graphs
consist of k disjoint sets of vertices, each of whose edges connects
vertices from distinct partitions.) 
      <li/><code>KPartiteSparseGraph</code>: an implementation of <code>KPartiteGraph</code>
which extends <code>SparseGraph</code>; it optionally creates subsets
for
each vertex partition (see Subsets/Partitions, below).
        <br>
A constructor is available that creates a new <code>KPartiteSparseGraph</code>
from an existing <code>Graph</code> whose vertices and edges satisfy
specified
constraints. The new graph contains all the user data from the original
graph and its components.
      
      <li/><code>BipartiteGraph</code> has not (yet) been formally
deprecated, but it has essentially been superseded by <code>KPartiteGraph</code>
and <code>KPartiteSparseGraph</code>.)
      
      <li/><code>PredicateUtils</code> is a new class that provides
utility methods for
dealing with constraints and subsets.
      
    </ul>
  
  <li/>Subsets/Partitions
    <ul>
      <li/><code>SubsetManager</code>: allows users to create, remove,
and access cached subsets
of vertices and edges. The membership of each subset is specified by a <code>Predicate</code>
(those vertices/edges that pass a given predicate are added to
the corresponding subset). An instance of <code>SubsetManager</code>,
when created,
adds itself to the <code>UserData</code> of the constructor-specified
graph (with key <code>ArchetypeGraph.SUBSET_MANAGER</code> and
registers itself as a listener to this graph, so that it can update the
memberships of the subsets as vertices and edges are added to and
removed from the graph. 
    </ul>
  
  <li/>Transformers
    <ul>
      <li/><code>KPartiteFolder</code>: converts a k-partite graph into
a 1-partite
graph. (This is a generalization of <code>BipartiteGraph.fold()</code>.)
      
      <li/><code>DirectionTransformer</code>: provides methods (formerly
part of <code>GraphUtils</code>)
for converting graphs of one type to another (e.g., directed to
undirected).
The <code>GraphUtils.transform</code> methods have been deprecated.
      
    </ul>
  
  <li/><code>AbstractArchetypeGraph</code>: implements those methods of <code>ArchetypeGraph</code>
which apply to all graph types (e.g., constraint management)
  
  <li/><code>BipartiteGraphReader</code>: Creates a <code>KPartiteGraph</code>
(k=2, aka a bipartite graph) based on structured input from a Java <code>Reader</code>.
Also provides partition-specific decoration methods.
  
  <li/>The <code>SparseVertex</code> class was designed to support
mixed-mode graphs with
parallel edges. For the sake of efficiency, we have created several new
vertex types
(<code>[Simple][[Un]Directed]SparseVertex</code>)
which are optimized for different combinations of directed, undirected,
and parallel edges; graphs which use the most restrictive vertex type
possible will be faster and require less memory.
  
  <li/><code>VertexGenerator</code>: an interface for vertex factories.
Implemented by
    <code>TypedVertexGenerator</code>, which, given a graph's edge
constraints, create a vertex of the most efficient implementation (of
those listed above) that supports edges with those constraints.
  
  <li/>EdgeStringer interface: returns a String for a given edge.
  
</ul>
<b>Changes</b>
<ul>
  <li/>Graph.isDirected() is now deprecated (AbstractSparseGraph calls
PredicateUtils.enforcesDirected())
  
  <li/>getEquivalent{Vertex,Edge}() has been deprecated in favor of
getEqual{Vertex,Edge}() to avoid confusion with the term "structural
equivalence" from the field of social network analysis.
  
  <li/>The distance-related methods have been refactored out of the <code>ShortestPath</code>
abstract class into a new interface, <code>Distance</code>.
These methods now specify that if the distance between two vertices
cannot be calculated
(for instance, because one is not reachable from the other for a
graph-based distance
metric), such a 'distance' should be represented as a null value.
    <br>
    <b>This has resulted in a change of behavior for the <code>DijkstraShortestPath</code>
and <code>UnweightedShortestPath</code> classes (which formerly used <code>Double.POSITIVE_INFINITY</code>
and <code>-1</code>, respectively, to indicate
unreachability).</b> 
  <li/>Since <code>DijkstraShortestPath</code> no longer is required to
generate distance values for unreachable vertices (see above), it tends
to run considerably faster
(and use less memory) if either of the following is true:
    <ul>
      <li/>the graph is not (strongly) connected (that is, if not all
vertices are reachable from the source vertex) 
      <li/>you are only asking for the closest k vertices to the source
vertex. 
    </ul>
  
  <li/><code>PajekNetFile</code> has been superseded by <code>PajekNetReader</code>
and <code>PajekNetWriter</code>. These classes can read and write
mixed-mode graphs,
make available different modes of vertex labeling (depending on whether
your labels must
be unique), have a more general edge weight decoration interface than <code>PajekNetFile</code>,
and are generally more robust (i.e., the Reader should be able to
handle a wider variety of
correctly formatted input than its predecessor).
  
  <li/><code>PajekNetFile</code> now takes a <code>Reader</code>
instead of a <code>BufferedReader</code>.
  
  <li/>Some bad calls (for example, trying to add a vertex to a graph
that is already
in that graph or another graph) now throw <code>IllegalArgumentException</code>
rather than
    <code>FatalException</code>.
  
  <li/><code>ArchetypeVertex.getEquivalentVertex()</code> and <code>ArchetypeEdge.getEquivalentEdge()</code>
have been renamed (deprecated) in favor of
    <code>getEqualVertex()</code> and <code>getEqualEdge()</code>
respectively. This better
reflects the fact that the <code>equals()</code> method respects the
relationship
described, and addresses the possible confusion with the term
"structural equivalence"
used in the social network analysis literature (and in the blockmodel
code introduced
in version 1.3).
  
  <li/><code>ToStringLabeller</code> now exists; it creates a
StringLabeller that will read from the
toString method of a vertex. Note that this is not settable.
  
  <li/><code>UserDataContainer</code> now supplies a <code>containsKey</code>
method that returns true if the object's user data repository contains
an item with this
key.
  
  <li/><code>UserData</code> has been refactored to reduce its memory
footprint.
  
  <li/>EdgeStringer is a new interface for labelling edges with strings;
the sample version is the
EdgeWeightLabellerStringer, which returns a string for each edge.
  
  <li/>KKLayoutInt added; this is a version of KKLayout that stores only
integers. This should look
similar; for some larger graphs, it may help economize on storage.
  
  <li/><code>AbstractSparseEdge.toString()</code> now returns a <code>String</code>
of the following format: <code>E[id]([v1.toString()],[v2.toString()])</code>.
(Previously the
edge's ID was not part of the string; <code>toString()</code> can now
distinguish between different parallel edges.)
  
  <li/><code>GraphUtil</code> methods <code>translateAll</code> and <code>translateAllEdges</code>
have been deprecated and replaced by <code>getEqualVertices</code> and
    <code>getEqualEdges</code>, respectively.
  
</ul>
<b>UI and GraphDraw changes</b>
<ul>
  <li/><code>GraphDraw</code>: By default, now HIDES the status bar;
call <code>showStatus()</code> to show it. 
  <li/>VisualizationViewer now guarantees that edge (x1, y1 x2, y2)
order sent to
the renderer is (front, back)
  
  <li/><code>SettableRenderer</code> improved:
    <ul>
      <li/>By default, the SettableRenderer now draws small squares, and
puts the text label on the side. (You may call
renderer.setLightDrawing( false ) to restore this) 
      <li/>SettableRenderer now draws self-loops when appropriate
(change with setShouldDrawSelfLoops) 
      <li/>... and arrows for directed edges (call
setShouldDrawDirectedArrows) 
      <li/>... but no arrows for undirected edges (call
setShouldDrawUndirectedArrows to change) 
      <li/>It labels edges with an "EdgeStringer" interface, which
returns a String for each edge. You may return a number with the
EdgeWeightLabellerStringer. 
      <li/>All methods are protected; it should be easy to override. 
    </ul>
  
  <li/>new Arrow class draws arrows pointing to vertices at the ends of
edges.
  
  <li/>EdgeThicknessFunction now returns a <code>float</code> rather
than <code>an int</code>. <b>This is a change in behavior, and may
require some
classes to be (slightly) rewritten.</b>
  
</ul>
<b>NewGraphDraw changes</b>
<ul>
  <li/>samples.preview_new_graphdraw is still in preview (but moving
toward beta fast).
There's a new architecture since the last time:
    <ul>
      <li/>An <b>EmittedLayout</b> stores (x,y) locations for vertices 
      <li/>A <b>StaticLayout</b> can initialize locations based on an
input dimension and a Graph object. This is the right choice for
iniital locations (e.g. CircleLayout) and for reading in a layout from
disk. 
      <li/>An <b>IterableLayout</b> can be initailized with a first
position, called with emit() to get the current state, and can be
called with advance() to move it forward. This divorces the calculation
step from the coding step, and so accelerates offscreen pre-iteration. 
      <li/>A <b>Transformer</b> modifies an EmittedLayout to (for
example) force it to the size of a diagram, or modify all vertices or
edges in a particular way. 
      <li/>An <b>EdgeRenderer</b> or <b>VertexRenderer</b> draws a
layout on screen. 
    </ul>
  
  <li/>The user may invoke a LocalGraphDraw with new LocalGraphDraw(
Graph, StaticLayout, [IterableLayout,] VertexRenderer, EdgeRenderer)
or may construct the elements on their own. They may extract the JPanel
within it,
by calling localGraphDraw.getPanel() and add that to a UI. The use of
the StaticLayout
at start ensures that there can be a deterministic view of the network.
  
  <li/>We provide several interesting systems to demonstrate the power
of this approach:
    <ul>
      <li/><tt>IterableFromStaticEmittedLayout</tt> is a StaticLayout
shows what happens with a layout after it has terminated. (This, it is
not necessary to watch animation on screen: it jumps to the
fully-laid-out mode.) 
      <li/><tt>IterableToStaticLayout</tt> does something similar,
although it starts from a StaticLayout. 
      <li/><tt>InterpolatingIterableLayout</tt> iterates from one
EmittedLayout into another. 
      <li/><tt>WrappedIterableLayout</tt> runs one iterable layout until
it has concluded, then runs another for several frames. 
      <li/><tt>UnmovingIterableLayout</tt> simulates an IterableLayout,
but doesn't move.
      
    </ul>
  
</ul>
<b>Bug Fixes</b>
<ul>
  <li/><code>GraphUtils.translateAll()</code> and <code>translateAllEdges()</code>
were storing a 'null' in the set of values returned if one of the
vertices/edges in the input set did not have an equal vertex/edge in
the target graph. This has been fixed.
  
  <li/>AbstractSparseVertex now has a working implementation of
findEdgeSet
  
  <li/><code>PajekNetFile.load()</code> no longer incorrectly rejects
.net files
that contain both an "*Arcs" and an "*Edges" specification (although it
does not read mixed-mode graphs; see below).
  
</ul>
<b>Known Issues</b>
<ul>
  <li/><code>PajekNetFile.load()</code> does not correctly handle
mixed-mode graphs; they
are interpreted as either strictly directed or strictly undirected.
(As noted above, <code>PajekNetFile</code> has been superseded by <code>PajekNetReader</code>
and <code>PajekNetWriter</code>.)
  
  <li/><code>PajekNetReader</code> does not currently correctly
interpret arcs or edges
in list form.
  
  <li/><code>BipartiteGraphReader</code> can load directed graphs, but
only those that
have directed edges that go from vertices in partition A to those in
partition B.
(The format cannot represent directed edges that go the other way.)
  
</ul>
<!--------- OLDER VERSIONS ------>
<hr>
<h3>1.3.0 (Washington's Birthday 2004)</h3>
<b>New Features</b>
<ul>
  <li/>Blockmodel code supports Structural Equivalence, and the ability
to
collapse sets of equivalent vertices.
  
  <li/>Classic Visualization system now supports mouse clicks (with
GraphMouseListener) and layouts that can change on the fly (with
LayoutMutable)
  
  <li/>Some methods and fields in visualization modified to be protected
instead of private.
  
  <li/>Preview visualization system now supports FitOnScreenLayout
  
  <li/><code>DijkstraShortestPath</code>: new methods allow the paths to
be extracted.
Includes some code contributed by Christoph Schmitz.
  
  <li/><code>ShortestPath</code>: new abstract class for shortest path
algorithms covers
DijkstraShortestPath and UnweightedShortestPath.
  
</ul>
<b>Bug Fixes</b>
<ul>
  <li/><code>DijkstraShortestPath</code>: fixed bug in vertex distance
comparisons
that caused distances to compare equal when they differed by less than
1.
Courtesy of Christoph Schmitz.
  
  <li/>Bug fix to GraphML
  
  <li/>Bug fix to UnweightedShortestPath
  
  <li/>BetweenessCentrality now works for directed graphs.
  
</ul>
<b>Changes</b>
<ul>
  <li/>Documentation for Vertex.findEdge() has been updated to clarify
its function
on directed edges, and now reads, in part:
    <blockquote> <code> Returns a directed outgoing edge from this
vertex to <code>v</code>, or an undirected edge that connects this
vertex to <code>v</code>. (Note that a directed incoming edge from <code>v</code>
to this vertex will <b>not</b> be returned: only elements of the edge
set returned by <code>getOutEdges()</code> will be returned by this
method.) </code>
    </blockquote>
  
  <li/>JUNG now requires version 3.0 of the commons-collections library
and
version 1.0.3 of the CERN COLT library. (Previous versions have known
bugs
which impact the JUNG routines.) See <a
 href="http://jung.sourceforge.net/download.html">this</a> for
information on how to get these libraries.
  
  <li/>SimulatedAnnealer removed temporarily from release: please
contact us if you need it back. Still available from CVS repository
under scratch.scott.optimization
  
</ul>
<hr>
<h3>1.2.0 (Julian Christmas 2003)</h3>
<b>New Features</b>
<ul>
  <li/>Added file I/O support for ascii matrices
  
  <li/>Preliminary Hypergraph support available (for graphs where
mutable edges can touch multiple vertices); while they cannot be used
for layout, visualization, or most algorithms, the data can be stored.
See Hypergraph and HypergraphBPG
  
  <li/> Graph event infrastructure added
  
  <li/>New layout algorithms contributed: <code>CircleLayout</code>, <code>KKLayout</code>,
    <code>DAGLayout</code>
    <blockquote> Note that these algorithms are not fully tested, and
may be quirky. In particular, KKLayout is known to have some irregular
difficulties when changing between layout algorithms; CircleLayout and
KKLayout do not fully respect filters. We felt that they are important
enough additions to add to the project anyway, and placed them in a
subpackage under visualization, "contrib". </blockquote>
  
  <li/>New graph generation algorithms added: <code>ErdosRenyi</code>
(contributed), <code>SimpleRandom</code> (contributed), <code>BarabasiAlbertGenerator</code>,
    <code>Lattice1DGenerator</code>, <code>Lattice2DGenerator</code>
  
  <li/>New contributed save routine for GraphMLFile
  
  <li/>Incident vertices of an <code>AbstractSparseEdge</code> can now
be
accessed with <code>getEndpoints()</code>, which returns a <code>Pair</code>.
  
  <li/><code>GraphUtils.equivalentGraphs(g1, g2)</code>: returns true
iff each
vertex and edge in <code>g1</code> has an equivalent in <code>g2</code>
and
vice versa.
  
  <li/><code>Vertex.findEdgeSet(Vertex)</code>: returns all edges that
connect these
two vertices as a <code>Set</code> [hook for parallel edge support]
  
</ul>
<b>Previews</b>
<ul>
  <li/><code>samples.graph.southern.BipartiteFile</code> reads in
bipartite files.
  
  <li/><code>samples.preview_new_graphdraw</code> previews a new
framework for visualizing graphs.
  
</ul>
<b>Changes</b>
<ul>
  <li/><code>addDirectedVertices</code> and <code>addUndirectedVertices</code>
in
GraphUtils now just forward their requests to <code>addVertices</code>.
The former methods will be removed shortly.
  
  <li/>BipartiteGraph now requires BipartiteVertex as well as
BipartiteEdge. 
  <li/>refactored <code>AbstractSparseEdge</code>, <code>AbstractSparseGraph</code>
to use edge IDs to define equivalence
    <ul>
      <li/>added <code>getEdgeById()</code> [internal method] and
corresponding data structure <code>mEdgeIDs</code> 
      <li/>note: this means that edge equivalence is now defined in the
same way as vertex equivalence: two edges are equivalent iff one is a
copy of (an ancestor-by-copy of) the other. This provides a more
consistent definition of equivalence, and enables the support of
parallel edges in a future release. 
    </ul>
  
  <li/>renamed <code>AbstractSparseGraph.mVertexLookupTable</code> to <code>mVertexIDs</code>
  
  <li/>moved down in the hierarchy from <code>ArchetypeGraph</code> to <code>Graph</code>
    <pre>    removeVertex(ArchetypeVertex) -&gt; Graph.removeVertex(Vertex)<br>    removeEdge(ArchetypeEdge) -&gt; Graph.removeEdge(Edge)<br>    addVertex(ArchetypeVertex) -&gt; Graph.addVertex(Vertex)<br>    addEdge(ArchetypeEdge) -&gt; Graph.addEdge(Edge)<br>    </pre>
  
  <li/>refactored out <code>AbstractSparseGraph.registerVertexID()</code>
back into <code>addVertex()</code>
  
  <li/><code>AbstractSparseEdge.copy()</code> now uses <code>clone()</code>
to create new edge rather than <code>GraphUtils.addEdge()</code>
  
  <li/><code>AbstractSparseGraph.mVertices</code> and <code>mEdges</code>
are now <code>HashSets</code>, not <code>LinkedHashSets</code>
  
  <li/>Fixed test cases for probabilistic algorithms <code>TestEppsteinPowerLawGenerator()
and
TestSimulatedAnnealer
    </code> now uses <code>clone()</code>
to create new edge rather than <code>GraphUtils.addEdge()</code>
  
  <li/><code>AbstractSparseGraph.mVertices</code> and <code>mEdges</code>
are now <code>HashSets</code>, not <code>LinkedHashSets</code>
  
</ul>
<b>Deleted</b>
<ul>
  <li/><code>removeAll*Edges()</code> signatures in
    <code>Vertex</code> and <code>ArchetypeVertex</code>, and
corresponding
methods from <code>AbstractSparseVertex</code>
(<code>removeAllIncidentEdges()</code> was moved into the deprecated
    <code>*DirectedSparseVertex classes</code>, to avoid breaking
existing
user code that might be using it)
  
  <li/><code>ArchetypeVertex.setEquivalentTo()</code> [had been
commented out]
  
  <li/><code>AbstractSparseEdge get{From, To}_internal</code>
(superseded by
    <code>AbstractSparseEdge.getEndpoints()</code>)
  
  <li/><code>AbstractSparseVertex.wipeVertex()</code> (replaced with
existing
    <code>AbstractSparseVertex.initialize()</code>)
  
  <li/><code>GraphUtils.getLabel(StringLabeller, Vertex)</code>
(use <code>StringLabeller.getLabel(Vertex)</code> instead)
  
</ul>
<b>Bug Fixes</b>
<ul>
  <li/>StringLabeller's ctor is now protected, so users can create their
own if they want.
  
  <li/>GraphUtils.copyLabels() now stores vertices from the target graph
in the
target StringLabeller.
  <li/>Added unit test for <code>BipartiteGraph.copy()</code>--and
modified the
graph heavily, as a result.
  <li/>The check for parallel edges has been moved from the
    <code>AbstractSparseEdge</code> constructor into
    <code>AbstractSparseGraph.addEdge()</code>. This will have no
effect on
code that does not create orphaned edges, but will do a better job of
enforcing the no-parallel-edge restriction than previous versions.
  
  <li/>replaced, in <code>AbstractSparseEdge.copy()</code> and
    <code>AbstractSparseVertex.copy()</code>:
    <br>
    <code>if (newGraph == this) --&gt; if (newGraph == this.getGraph())</code>
  
  <li/>visibility of (<code>DirectedEdge.get{Source, Dest},
Edge.getOpposite(),
ArchetypeEdge.copy()</code>, and most of <code>ArchetypeVertex</code>)
are now public (were package-visible)
  
  <li/><code>AbstractSparseGraph.removeVertices()</code>: now does not
operate directly on set given to it, but on a new HashSet made from it
  
  <li/>removed dependence on vertex set ordering from <code>TestPajekNetFile</code>,
    <code>GraphMatrixOperationsTest</code>
  
</ul>
<b>Known Issues</b>
<ul>
  <li/>The behavior of the following methods is undefined if the
invoking object
and the parameter are not elements of the same graph:
    <code>ArchetypeEdge.isIncident(ArchetypeVertex)</code>,
    <code>ArchetypeVertex</code>: <code>isIncident(ArchetypeEdge)</code>
and
    <code>isNeighbor(ArchetypeVertex)</code>, and <code>Vertex</code>:
    <code>isPredecessorOf(Vertex)</code>, <code>isSuccessorOf(Vertex)</code>,
    <code>isSource(Edge)</code>, and <code>isDest(Edge)</code>.
  
</ul>
<hr>
<h3>Version 1.1.1 (Interim Release, Thanksgiving 2003)</h3>
<b>New Features/Changes</b>
<ul>
  <li/>Jars are now named as <i>jung-1.1.1.jar</i>: be sure to delete
your previous
version from your classpath, or rename this to jung.jar to overwrite.
  
  <li/><b><code>SparseVertex</code> is the new canonical type for the
Vertex implementation.
    <code>Directed</code> and <code>UndirectedSparseVertex</code> are
now <i>deprecated</i>
(and will show as such when you compile). The result of this is that a
Vertex no longer
cares whether it is directed or not; indeed, it may have both directed
and undirected edges
attached to it (in which case, Graph.isDirected() will throw an
exception).</b>
  
  <li/>Thus, vertex "directionality" has been eliminated:
    <ul>
      <li/>new class <code>SparseVertex</code>: replaces now-deprecated
        <code>DirectedSparseVertex</code> and <code>UndirectedSparseVertex</code>
      
      <li/><code>GraphUtils.addVertices()</code> now correct <code>GraphUtils</code>
method to add multiple vertices to a graph (other <code>add*Vertices()</code>
methods deprecated) 
    </ul>
  
  <li/><code>BipartiteGraph.getPartition(Vertex)</code> returns the
partition of a vertex in a <code>BipartiteGraph</code>
  
  <li/><code>SettableRenderer</code> now no longer kills a GraphDraw
process if it can't find
a StringLabeller associated with the graph; rather, it draws a "?" on
the vertex.
  
  <li/><code>DijkstraShortestPath</code> can now control whether results
are cached or not
(constructor and new method <code>enableCaching</code>)
  
  <li/>It is now possible to terminate a <code>Relaxer</code> thread
inside a <code>VisualizationViewer</code>
with <code>GraphDraw.stop()</code> or <code>VisualizationViewer.stop()</code>.
  
  <li/><code>DropSoloNodeFilter</code> can now be extended.
  
  <li/>new counting methods for vertices:
    <ul>
      <li/><code>ArchetypeVertex.numNeighbors()</code> returns the
number of
neighbors that the vertex has 
    </ul>
    <code>Vertex.numPredecessors()</code> and <code>numSuccessors()</code>
return the number of predecessors and successors that the vertex has.
  
</ul>
<b>Bug Fixes</b>
<ul>
  <li/>documentation for PageRank and PageRankWithPriors now correctly
states time complexity
  
  <li/>BipartiteGraph: getAllVertices(): now throws if given invalid
partition
    <br>
getPartition(): new method, returns partition of a given vertex
    <br>
addVertex(): now throws if vertex has already been inserted; error
message depends on partition selected
  
</ul>
<b>Known Issues</b>
<ul>
  <li/>GraphDraw is still hard to control (especially in getting
events in and out, and for handling objects that are not dots
connected by straight lines); the entire mechanism is being replaced.
  
  <li/>Decorators are still being improved; the mechanism may
shortly be modified.
  
</ul>
<hr>
<h3>Version 1.1</h3>
<b>New Features/Changes</b>
<ul>
  <li/>added new community finding algorithm: ExactFlowCommunity
  
  <li/>added two new node betweenness algorithms: RandomWalkBetweenness
and RandomWalkSTBetwenness
  
  <li/>added new graph generator to generate small world networks using
Watts' beta model: BetaSmallWorldGenerator
  
  <li/>Added min-cut edge retrieval to EdmondsKarpMaxFlow
  
  <li/>Added directed to undirected graph transformations in GraphUtils
  
  <li/>modified GraphMatrixOperations.graphToSparseMatrix method to
support adjacency matrices
  
  <li/>added GraphMatrixOperations.computeVoltageMatrix
  
  <li/>added new method
GraphMatrixOperations.createVertexDegreeDiagonalMatrix
  
  <li/>ArchetypeVertex (and subclasses): renamed isNeighbor() to
isNeighborOf() (for similarity with isPredecessorOf() and
isSuccessorOf() )
  
  <li/>DijkstraShortestPath
    <ul>
      <li/>caches results in class, does not decorate vertices 
      <li/>map returned is ordered by distance to source 
      <li/>calculation of k nearest vertices 
      <li/>incremental calculation (uses old partial results as a
starting point) 
      <li/>constructor now takes NumberEdgeValue 
      <li/>allows early termination when distance to target vertex found
      
    </ul>
  
  <li/>BipartiteGraph
    <ul>
      <li/>new data structure for bipartite graphs 
      <li/>provides a method <code>fold()</code> which converts
bipartite graphs to general binary graphs 
    </ul>
  
</ul>
<b>Bug Fixes</b>
<ul>
  <li/>Fixed GraphStatistics.clusteringCoefficients 
  <li/>Fixed EppsteinPowerLawGraphGenerator 
  <li/>Remove LinkedHashSet order dependency for TestBFSDistanceLabeller
and TestExactFlowCommunity 
  <li/>AbstractSparseVertex.copy() now throws IllegalArgumentException
if source and destination graphs are the same (was: FatalException) 
  <li/>AbstractSparseEdge.copy() now throws IllegalArgumentException if
source and destination graphs are the same (previously: not checked) 
  <li/>AbstractSparseGraph.removeVertex(): vertex ID was not being
removed from hash table 
  <li/>DijkstraShortestPath now works (reimplemented; see above for new
features)
  
</ul>
<b>New Documentation</b>
<ul>
  <li/>algorithms.cluster: definitions of "biconnected", "betweenness",
and "weakly connected" have been added 
  <li/>io.PajekNetFile: changed documentation so that it specifies that
vertices must be specified <i>in order</i> from 1 to n 
  <li/>added another example to GraphMLFile 
  <li/>StringLabeller, EdgeWeightLabeller, Indexer corrected and
enhanced. Decorator clarifies the role and location of its storage
because it deeply affects what happens when you add or remove vertices.
  
</ul>
<b>Known Issues</b>
<ul>
  <li/>decorators
    <ul>
      <li/>offset tag for values &gt; 0 may be dangerous, and must be
used with caution 
      <li/>StringLabeller expects unique labels. This may not always be
what you want. 
    </ul>
  
  <li/>utils
    <ul>
      <li/>GeneralUtils, UserDataUtils: no docs 
      <li/>docs of CopyAction.{Clone, Remove, Shared} incorrect: they do
not implement UserData.{CLONE, REMOVE, SHARED}, but are classes of
which the latter are instances 
      <li/>docs of UserData.SHARED: confusing. Code examples are best
laid out in lines rather than all on the same line, and an example that
actually uses UserData would be better. 
      <li/>docs of UserData.REMOVE: "useful for temporary userdata that
isn't used"? (Huh?) 
    </ul>
  
  <li/>samples
    <ul>
      <li/>BasicRenderer has no Javadoc 
    </ul>
  
  <li/>graph.impl
    <ul>
      <li/>lack of type safety in addEdge/Vertex, edge constructors, ...
      
    </ul>
  
</ul>
</body>
</html>
